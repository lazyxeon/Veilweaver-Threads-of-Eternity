<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AstraWeave: AI-Native Game Engine Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for AstraWeave, the first AI-native game engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AstraWeave: AI-Native Game Engine Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lazyxeon/AstraWeave-AI-Native-Gaming-Engine" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="astraweave-ai-native-game-engine-documentation"><a class="header" href="#astraweave-ai-native-game-engine-documentation">AstraWeave: AI-Native Game Engine Documentation</a></h1>
<p>Welcome to the comprehensive documentation for <strong>AstraWeave</strong>, the first game engine built from the ground up for AI-native gameplay.</p>
<h2 id="what-is-astraweave"><a class="header" href="#what-is-astraweave">What is AstraWeave?</a></h2>
<p>AstraWeave is a deterministic, ECS-based game engine where <strong>AI agents are first-class citizens</strong>. Unlike traditional engines where AI is bolted on as an afterthought, AstraWeave implements the core AI loop (<strong>Perception ‚Üí Reasoning ‚Üí Planning ‚Üí Action</strong>) directly into the simulation architecture.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<p>üß† <strong>AI-Native Architecture</strong> - Agents plan through sandboxed tools with full engine validation<br />
üéØ <strong>Deterministic Simulation</strong> - 60Hz fixed-tick simulation with authoritative validation<br />
üõ°Ô∏è <strong>Tool Sandbox Security</strong> - AI can only act through validated verbs (no cheating)<br />
ü§ù <strong>Persistent Companions</strong> - AI profiles that learn and adapt across sessions<br />
üé≠ <strong>Adaptive Boss Systems</strong> - Directors that evolve tactics and reshape battlefields<br />
üåê <strong>Local-First AI</strong> - 7B-12B quantized LLMs for low-latency decisions</p>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who is This For?</a></h2>
<p>This documentation serves different types of users:</p>
<h3 id="-game-developers"><a class="header" href="#-game-developers">üéÆ Game Developers</a></h3>
<ul>
<li>Want to build games with intelligent AI companions</li>
<li>Need dynamic bosses that adapt to player strategies</li>
<li>Seek emergent gameplay from AI agent interactions</li>
<li><strong>Start with:</strong> <a href="./getting-started/quick-start.html">Quick Start Guide</a></li>
</ul>
<h3 id="-engine-contributors"><a class="header" href="#-engine-contributors">üîß Engine Contributors</a></h3>
<ul>
<li>Want to contribute to the engine's core systems</li>
<li>Interested in AI-native architecture design</li>
<li>Need to understand the codebase structure</li>
<li><strong>Start with:</strong> <a href="./dev/contributing.html">Contributing Guide</a></li>
</ul>
<h3 id="-ai-researchers"><a class="header" href="#-ai-researchers">üß† AI Researchers</a></h3>
<ul>
<li>Studying AI-native game architectures</li>
<li>Interested in perception, planning, and validation systems</li>
<li>Want to understand tool-based AI validation</li>
<li><strong>Start with:</strong> <a href="./architecture/ai-native.html">AI-Native Design</a></li>
</ul>
<h3 id="-students--learners"><a class="header" href="#-students--learners">üìö Students &amp; Learners</a></h3>
<ul>
<li>Learning about game engine architecture</li>
<li>Understanding ECS and deterministic simulation</li>
<li>Exploring AI in games</li>
<li><strong>Start with:</strong> <a href="./architecture/overview.html">Architecture Overview</a></li>
</ul>
<h2 id="quick-navigation"><a class="header" href="#quick-navigation">Quick Navigation</a></h2>
<ul>
<li><strong>New to AstraWeave?</strong> ‚Üí <a href="./getting-started/quick-start.html">Quick Start Guide</a></li>
<li><strong>Want to build a game?</strong> ‚Üí <a href="./game-dev/first-game.html">Building Your First Game</a></li>
<li><strong>Need API reference?</strong> ‚Üí <a href="./api/index.html">API Documentation</a></li>
<li><strong>Looking for examples?</strong> ‚Üí <a href="./examples/index.html">Working Examples</a></li>
<li><strong>Want to contribute?</strong> ‚Üí <a href="./dev/contributing.html">Contributing Guide</a></li>
<li><strong>Having issues?</strong> ‚Üí <a href="./resources/troubleshooting.html">Troubleshooting</a></li>
</ul>
<h2 id="reference-implementation-veilweaver"><a class="header" href="#reference-implementation-veilweaver">Reference Implementation: Veilweaver</a></h2>
<p><strong>Veilweaver: Threads of Eternity</strong> serves as AstraWeave's reference implementation‚Äîa complete AI-native Action RPG that demonstrates the engine's capabilities. Learn more in the <a href="./veilweaver/overview.html">Veilweaver section</a>.</p>
<hr />
<p><em>Ready to build the future of AI-native gaming? Let's get started!</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get up and running with AstraWeave in minutes! This guide will help you install the engine, run your first AI companion, and understand the basic concepts.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust</strong>: 1.89.0+ (managed automatically via <code>rust-toolchain.toml</code>)</li>
<li><strong>Platform</strong>: Linux, macOS, or Windows</li>
<li><strong>GPU</strong>: Vulkan-compatible graphics card</li>
<li><strong>Memory</strong>: 4GB+ RAM recommended for AI models</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="1-clone-the-repository"><a class="header" href="#1-clone-the-repository">1. Clone the Repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/lazyxeon/AstraWeave-AI-Native-Gaming-Engine.git
cd AstraWeave-AI-Native-Gaming-Engine
</code></pre>
<h3 id="2-system-dependencies-linux"><a class="header" href="#2-system-dependencies-linux">2. System Dependencies (Linux)</a></h3>
<p>If you're on Linux, install the required system packages:</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install -y build-essential pkg-config cmake ninja-build \
  libx11-dev libxi-dev libxcursor-dev libxrandr-dev libxinerama-dev \
  libxkbcommon-dev libxkbcommon-x11-dev libx11-xcb-dev libxcb1-dev \
  libxcb-randr0-dev libxcb-xfixes0-dev libxcb-shape0-dev libxcb-xkb-dev \
  libgl1-mesa-dev libegl1-mesa-dev wayland-protocols libwayland-dev \
  libasound2-dev libpulse-dev libudev-dev mesa-vulkan-drivers vulkan-tools
</code></pre>
<h3 id="3-build-core-components"><a class="header" href="#3-build-core-components">3. Build Core Components</a></h3>
<p>Build the stable, working core components:</p>
<pre><code class="language-bash">cargo build -p astraweave-core -p astraweave-ai -p astraweave-physics \
            -p astraweave-nav -p astraweave-render -p hello_companion
</code></pre>
<p>This typically takes 8-15 seconds after initial dependency download.</p>
<h2 id="your-first-ai-companion"><a class="header" href="#your-first-ai-companion">Your First AI Companion</a></h2>
<p>Let's run the most basic example to see AstraWeave in action:</p>
<pre><code class="language-bash">cargo run -p hello_companion --release
</code></pre>
<h3 id="what-youll-see"><a class="header" href="#what-youll-see">What You'll See</a></h3>
<p>The demo will show:</p>
<ol>
<li><strong>AI Perception</strong>: The companion perceives the world state</li>
<li><strong>Planning</strong>: AI generates a plan using its understanding</li>
<li><strong>Tool Validation</strong>: The engine validates what the AI wants to do</li>
<li><strong>Expected Panic</strong>: The demo will panic with "LosBlocked" - this is expected behavior demonstrating the validation system</li>
</ol>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code>[INFO] AI Companion initialized
[INFO] Perception snapshot captured: 1 entities
[INFO] Planning phase: generating intent for companion
[INFO] Generated plan: MoveTo(target_position)
[INFO] Validating tool usage: MovementTool
[ERROR] Validation failed: LosBlocked
thread 'main' panicked at 'LOS validation failed'
</code></pre>
<p><strong>This panic is intentional!</strong> It demonstrates AstraWeave's core principle: <em>the AI can only do what the engine validates as possible</em>.</p>
<h2 id="understanding-what-happened"><a class="header" href="#understanding-what-happened">Understanding What Happened</a></h2>
<p>The hello_companion example showcases AstraWeave's fundamental architecture:</p>
<ol>
<li><strong>Fixed-Tick Simulation</strong>: The world runs at deterministic 60Hz</li>
<li><strong>AI Perception</strong>: AI agents receive structured world snapshots</li>
<li><strong>Planning Layer</strong>: AI generates intentions using LLM-based planning</li>
<li><strong>Tool Validation</strong>: Engine validates every AI action before execution</li>
<li><strong>Safety First</strong>: Invalid actions are rejected, maintaining game integrity</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you've seen the core loop in action:</p>
<ul>
<li><strong>Learn the Architecture</strong>: Read <a href="getting-started/../architecture/ai-native.html">AI-Native Design</a></li>
<li><strong>Build Your First Game</strong>: Follow <a href="getting-started/../game-dev/first-game.html">Building Your First Game</a></li>
<li><strong>Explore More Examples</strong>: Check out <a href="getting-started/../examples/index.html">Working Examples</a></li>
<li><strong>Dive Deeper</strong>: Study <a href="getting-started/../core-systems/ai/index.html">Core Systems</a></li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="build-errors"><a class="header" href="#build-errors">Build Errors</a></h3>
<p>If you encounter build errors:</p>
<ul>
<li>Make sure you have the correct Rust version (check <code>rust-toolchain.toml</code>)</li>
<li>Install system dependencies for your platform</li>
<li>Some examples have known compilation issues - stick to the working core components listed above</li>
</ul>
<h3 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h3>
<ul>
<li><strong>Graphics errors</strong>: Ensure you have Vulkan drivers installed</li>
<li><strong>Audio errors</strong>: Install audio system dependencies (ALSA/PulseAudio on Linux)</li>
<li><strong>Permission errors</strong>: Make sure your user can access graphics and audio devices</li>
</ul>
<p>For more help, see <a href="getting-started/../resources/troubleshooting.html">Troubleshooting</a>.</p>
<hr />
<p><strong>üéâ Congratulations!</strong> You've successfully run your first AstraWeave AI companion. The engine validated the AI's actions and maintained world integrity, just as it should.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-guide"><a class="header" href="#installation-guide">Installation Guide</a></h1>
<p>This guide covers detailed installation instructions for AstraWeave on different platforms, including all dependencies and troubleshooting common issues.</p>
<h2 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h2>
<h3 id="minimum-requirements"><a class="header" href="#minimum-requirements">Minimum Requirements</a></h3>
<ul>
<li><strong>CPU</strong>: x64 processor with SSE2 support</li>
<li><strong>Memory</strong>: 4GB RAM (8GB+ recommended for AI models)</li>
<li><strong>GPU</strong>: Vulkan 1.0 compatible graphics card</li>
<li><strong>Storage</strong>: 2GB free space (more for AI models)</li>
<li><strong>Rust</strong>: 1.89.0+ (managed via rust-toolchain.toml)</li>
</ul>
<h3 id="recommended-requirements"><a class="header" href="#recommended-requirements">Recommended Requirements</a></h3>
<ul>
<li><strong>CPU</strong>: Multi-core x64 processor (4+ cores)</li>
<li><strong>Memory</strong>: 16GB+ RAM for development and multiple AI models</li>
<li><strong>GPU</strong>: Modern Vulkan 1.2+ compatible GPU with 2GB+ VRAM</li>
<li><strong>Storage</strong>: SSD with 10GB+ free space</li>
</ul>
<h2 id="platform-specific-installation"><a class="header" href="#platform-specific-installation">Platform-Specific Installation</a></h2>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<h4 id="ubuntudebian"><a class="header" href="#ubuntudebian">Ubuntu/Debian</a></h4>
<pre><code class="language-bash"># Update package lists
sudo apt-get update

# Install build essentials
sudo apt-get install -y build-essential pkg-config cmake ninja-build

# Install graphics dependencies
sudo apt-get install -y libx11-dev libxi-dev libxcursor-dev libxrandr-dev \
  libxinerama-dev libxkbcommon-dev libxkbcommon-x11-dev libx11-xcb-dev \
  libxcb1-dev libxcb-randr0-dev libxcb-xfixes0-dev libxcb-shape0-dev \
  libxcb-xkb-dev

# Install rendering dependencies
sudo apt-get install -y libgl1-mesa-dev libegl1-mesa-dev wayland-protocols \
  libwayland-dev mesa-vulkan-drivers vulkan-tools

# Install audio dependencies  
sudo apt-get install -y libasound2-dev libpulse-dev

# Install additional system dependencies
sudo apt-get install -y libudev-dev
</code></pre>
<h4 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h4>
<pre><code class="language-bash"># Install base development tools
sudo pacman -S base-devel cmake ninja

# Install graphics and audio
sudo pacman -S vulkan-devel mesa alsa-lib libpulse wayland wayland-protocols

# Install X11 dependencies
sudo pacman -S libx11 libxcb libxrandr libxinerama libxcursor libxi
</code></pre>
<h4 id="fedorarhel"><a class="header" href="#fedorarhel">Fedora/RHEL</a></h4>
<pre><code class="language-bash"># Install development tools
sudo dnf groupinstall "Development Tools"
sudo dnf install cmake ninja-build pkg-config

# Install graphics dependencies
sudo dnf install libX11-devel libXi-devel libXcursor-devel libXrandr-devel \
  libXinerama-devel libxkbcommon-devel libxkbcommon-x11-devel

# Install Vulkan and Mesa
sudo dnf install vulkan-devel mesa-dri-drivers

# Install audio
sudo dnf install alsa-lib-devel pulseaudio-libs-devel
</code></pre>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<h4 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h4>
<p>First, install Xcode Command Line Tools:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<h4 id="using-homebrew-recommended"><a class="header" href="#using-homebrew-recommended">Using Homebrew (Recommended)</a></h4>
<pre><code class="language-bash"># Install Homebrew if not already installed
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Install dependencies
brew install cmake ninja pkg-config

# For Intel Macs, ensure MoltenVK is installed
brew install molten-vk
</code></pre>
<h4 id="manual-installation"><a class="header" href="#manual-installation">Manual Installation</a></h4>
<ul>
<li>Download and install Xcode from the App Store</li>
<li>Install CMake from <a href="https://cmake.org/download/">cmake.org</a></li>
<li>Ensure MoltenVK is available for Vulkan support</li>
</ul>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<h4 id="using-visual-studio-recommended"><a class="header" href="#using-visual-studio-recommended">Using Visual Studio (Recommended)</a></h4>
<ol>
<li>Install Visual Studio 2019 or later with C++ build tools</li>
<li>Install Git for Windows</li>
<li>Install CMake (either standalone or via Visual Studio Installer)</li>
</ol>
<h4 id="using-msys2mingw"><a class="header" href="#using-msys2mingw">Using MSYS2/MinGW</a></h4>
<pre><code class="language-bash"># Install MSYS2 from https://www.msys2.org/
# Then in MSYS2 terminal:
pacman -S mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja
pacman -S mingw-w64-x86_64-vulkan-devel
</code></pre>
<h2 id="rust-installation"><a class="header" href="#rust-installation">Rust Installation</a></h2>
<p>AstraWeave uses a specific Rust version defined in <code>rust-toolchain.toml</code>. The installation process will automatically use the correct version.</p>
<h3 id="install-rust"><a class="header" href="#install-rust">Install Rust</a></h3>
<pre><code class="language-bash"># Install rustup (Rust installer)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Follow the prompts, then restart your terminal or run:
source ~/.cargo/env

# Verify installation
rustc --version
cargo --version
</code></pre>
<h3 id="rust-components"><a class="header" href="#rust-components">Rust Components</a></h3>
<p>The following components will be installed automatically when needed:</p>
<ul>
<li><code>cargo</code> - Package manager and build tool</li>
<li><code>clippy</code> - Linter for catching common mistakes</li>
<li><code>rustfmt</code> - Code formatter</li>
<li><code>rust-analyzer</code> - Language server for IDE support</li>
</ul>
<h2 id="clone-and-build"><a class="header" href="#clone-and-build">Clone and Build</a></h2>
<h3 id="1-clone-the-repository-1"><a class="header" href="#1-clone-the-repository-1">1. Clone the Repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/lazyxeon/AstraWeave-AI-Native-Gaming-Engine.git
cd AstraWeave-AI-Native-Gaming-Engine
</code></pre>
<h3 id="2-verify-rust-toolchain"><a class="header" href="#2-verify-rust-toolchain">2. Verify Rust Toolchain</a></h3>
<p>The correct Rust version will be installed automatically:</p>
<pre><code class="language-bash"># This will show the version from rust-toolchain.toml
rustc --version
</code></pre>
<h3 id="3-build-core-components-1"><a class="header" href="#3-build-core-components-1">3. Build Core Components</a></h3>
<p>Start with the stable, working components:</p>
<pre><code class="language-bash">cargo build -p astraweave-core -p astraweave-ai -p astraweave-physics \
            -p astraweave-nav -p astraweave-render -p hello_companion
</code></pre>
<h3 id="4-run-tests"><a class="header" href="#4-run-tests">4. Run Tests</a></h3>
<p>Verify the installation with tests:</p>
<pre><code class="language-bash">cargo test -p astraweave-input
</code></pre>
<h3 id="5-run-example"><a class="header" href="#5-run-example">5. Run Example</a></h3>
<p>Test the installation:</p>
<pre><code class="language-bash">cargo run -p hello_companion --release
</code></pre>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<h3 id="check-gpu-support"><a class="header" href="#check-gpu-support">Check GPU Support</a></h3>
<pre><code class="language-bash"># Linux: Check Vulkan
vulkaninfo | grep "deviceName"

# macOS: Check Metal
system_profiler SPDisplaysDataType

# Windows: Use dxdiag or GPU-Z
</code></pre>
<h3 id="check-audio"><a class="header" href="#check-audio">Check Audio</a></h3>
<pre><code class="language-bash"># Linux: Test audio devices
aplay -l

# macOS: Check audio
system_profiler SPAudioDataType  

# Windows: Check audio devices in Device Manager
</code></pre>
<h2 id="development-environment-setup"><a class="header" href="#development-environment-setup">Development Environment Setup</a></h2>
<h3 id="ide-recommendations"><a class="header" href="#ide-recommendations">IDE Recommendations</a></h3>
<h4 id="vs-code-recommended"><a class="header" href="#vs-code-recommended">VS Code (Recommended)</a></h4>
<p>Install these extensions:</p>
<ul>
<li><code>rust-analyzer</code> - Rust language support</li>
<li><code>CodeLLDB</code> - Debugging support</li>
<li><code>Even Better TOML</code> - TOML file support</li>
<li><code>Error Lens</code> - Inline error display</li>
</ul>
<h4 id="other-ides"><a class="header" href="#other-ides">Other IDEs</a></h4>
<ul>
<li><strong>CLion</strong>: Has good Rust support with the Rust plugin</li>
<li><strong>Vim/Neovim</strong>: Use with rust-analyzer LSP</li>
<li><strong>Emacs</strong>: Use with rust-analyzer and rustic-mode</li>
</ul>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<h4 id="release-builds"><a class="header" href="#release-builds">Release Builds</a></h4>
<p>For better performance during development:</p>
<pre><code class="language-bash"># Always use release mode for examples
cargo run -p hello_companion --release

# Build in release mode
cargo build --release
</code></pre>
<h4 id="parallel-compilation"><a class="header" href="#parallel-compilation">Parallel Compilation</a></h4>
<p>Speed up builds by using multiple CPU cores:</p>
<pre><code class="language-bash"># Set in ~/.cargo/config.toml
[build]
jobs = 4  # or number of CPU cores
</code></pre>
<h4 id="target-directory"><a class="header" href="#target-directory">Target Directory</a></h4>
<p>Use a shared target directory to reduce disk usage:</p>
<pre><code class="language-bash"># Set CARGO_TARGET_DIR environment variable
export CARGO_TARGET_DIR=/path/to/shared/target
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="common-build-errors"><a class="header" href="#common-build-errors">Common Build Errors</a></h3>
<h4 id="linker-not-found"><a class="header" href="#linker-not-found">"linker not found"</a></h4>
<ul>
<li><strong>Linux</strong>: Install <code>build-essential</code> or <code>gcc</code></li>
<li><strong>macOS</strong>: Install Xcode Command Line Tools</li>
<li><strong>Windows</strong>: Install Visual Studio with C++ tools</li>
</ul>
<h4 id="vulkan-errors"><a class="header" href="#vulkan-errors">Vulkan errors</a></h4>
<ul>
<li><strong>Linux</strong>: Install <code>mesa-vulkan-drivers</code> and <code>vulkan-tools</code></li>
<li><strong>macOS</strong>: Ensure MoltenVK is installed</li>
<li><strong>Windows</strong>: Update graphics drivers</li>
</ul>
<h4 id="audio-errors"><a class="header" href="#audio-errors">Audio errors</a></h4>
<ul>
<li><strong>Linux</strong>: Install <code>libasound2-dev</code> and <code>libpulse-dev</code></li>
<li><strong>macOS</strong>: Usually works out of the box</li>
<li><strong>Windows</strong>: Ensure Windows Audio service is running</li>
</ul>
<h3 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h3>
<h4 id="slow-compilation"><a class="header" href="#slow-compilation">Slow Compilation</a></h4>
<ul>
<li>Use <code>cargo build --release</code> for better runtime performance</li>
<li>Consider using <code>sccache</code> to cache compilation results</li>
<li>Increase parallel build jobs in Cargo config</li>
</ul>
<h4 id="runtime-performance"><a class="header" href="#runtime-performance">Runtime Performance</a></h4>
<ul>
<li>Always use <code>--release</code> flag for examples and demos</li>
<li>Ensure GPU drivers are up to date</li>
<li>Check system has adequate RAM (4GB minimum)</li>
</ul>
<h3 id="platform-specific-issues"><a class="header" href="#platform-specific-issues">Platform-Specific Issues</a></h3>
<h4 id="linux-wayland-vs-x11"><a class="header" href="#linux-wayland-vs-x11">Linux Wayland vs X11</a></h4>
<p>AstraWeave supports both Wayland and X11:</p>
<pre><code class="language-bash"># Force X11 if needed
export WAYLAND_DISPLAY=""

# Force Wayland if needed  
export DISPLAY=""
</code></pre>
<h4 id="macos-code-signing"><a class="header" href="#macos-code-signing">macOS Code Signing</a></h4>
<p>For distribution on macOS, you may need to sign binaries:</p>
<pre><code class="language-bash">codesign --force --deep --sign - target/release/hello_companion
</code></pre>
<h4 id="windows-antivirus"><a class="header" href="#windows-antivirus">Windows Antivirus</a></h4>
<p>Some antivirus software may flag Rust binaries. Add exclusions for:</p>
<ul>
<li>The project directory</li>
<li><code>~/.cargo</code> directory</li>
<li><code>target/</code> build directory</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>With AstraWeave installed:</p>
<ol>
<li>Run through the <a href="getting-started/./quick-start.html">Quick Start Guide</a></li>
<li>Explore <a href="getting-started/../examples/index.html">Working Examples</a></li>
<li>Read about <a href="getting-started/../architecture/overview.html">Architecture</a></li>
<li>Build <a href="getting-started/../game-dev/first-game.html">Your First Game</a></li>
</ol>
<p>For ongoing development, see the <a href="getting-started/../dev/contributing.html">Contributing Guide</a> and <a href="getting-started/../dev/building.html">Building from Source</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-ai-companion-1"><a class="header" href="#your-first-ai-companion-1">Your First AI Companion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-requirements-1"><a class="header" href="#system-requirements-1">System Requirements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>AstraWeave represents a fundamental shift in game engine design: instead of treating AI as an afterthought, it places intelligent agents at the core of the architecture. This document explains the key architectural decisions and how they enable truly AI-native gameplay.</p>
<h2 id="core-philosophy-ai-first-design"><a class="header" href="#core-philosophy-ai-first-design">Core Philosophy: AI-First Design</a></h2>
<p>Traditional game engines follow this pattern:</p>
<pre><code>Game Logic ‚Üí AI System ‚Üí Scripted Behaviors
</code></pre>
<p>AstraWeave inverts this relationship:</p>
<pre><code>AI Agents ‚Üê Tool Validation ‚Üê Engine Authority
</code></pre>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<ol>
<li><strong>No Cheating AI</strong>: AI can only act through validated game systems</li>
<li><strong>Emergent Behavior</strong>: Complex interactions emerge from simple, validated tools</li>
<li><strong>Multiplayer Ready</strong>: Same validation works for human players and AI</li>
<li><strong>Predictable Performance</strong>: Deterministic simulation enables reliable testing</li>
</ol>
<h2 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-Level Architecture</a></h2>
<pre><code class="language-mermaid">graph TB
    subgraph "Fixed-Tick Simulation (60Hz)"
        ECS[ECS World]
        Physics[Physics System]
        Audio[Audio System]
        Render[Render System]
    end
    
    subgraph "AI Pipeline"
        Perception[Perception Bus]
        Planning[AI Planning]
        Tools[Tool Sandbox]
        Validation[Engine Validation]
    end
    
    subgraph "Game Layer"
        Gameplay[Gameplay Systems]
        Content[Content Systems]
        UI[UI Systems]
    end
    
    ECS --&gt; Perception
    Perception --&gt; Planning
    Planning --&gt; Tools
    Tools --&gt; Validation
    Validation --&gt; ECS
    
    ECS --&gt; Physics
    ECS --&gt; Audio
    ECS --&gt; Render
    
    Gameplay --&gt; ECS
    Content --&gt; ECS
    UI --&gt; ECS
</code></pre>
<h2 id="the-deterministic-core"><a class="header" href="#the-deterministic-core">The Deterministic Core</a></h2>
<h3 id="fixed-tick-simulation"><a class="header" href="#fixed-tick-simulation">Fixed-Tick Simulation</a></h3>
<p>AstraWeave runs the simulation at exactly 60Hz, regardless of rendering framerate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TICK_RATE: f64 = 60.0;
const TICK_DURATION: Duration = Duration::from_nanos(16_666_667); // 1/60 second

// Simulation always advances by exactly this amount
fn tick_simulation(&amp;mut self) {
    self.world.step(TICK_DURATION);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Deterministic physics and AI behavior</li>
<li>Consistent timing across different hardware</li>
<li>Reliable networking and replay systems</li>
<li>Predictable performance testing</li>
</ul>
<h3 id="entity-component-system-ecs"><a class="header" href="#entity-component-system-ecs">Entity-Component-System (ECS)</a></h3>
<p>AstraWeave uses an archetype-based ECS for cache-friendly performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Components are pure data
#[derive(Component)]
struct Position(Vec3);

#[derive(Component)]  
struct AIAgent {
    perception_range: f32,
    planning_cooldown: Duration,
}

// Systems operate on component combinations
fn ai_perception_system(
    query: Query&lt;(&amp;Position, &amp;AIAgent, &amp;mut PerceptionState)&gt;
) {
    for (pos, agent, mut perception) in query.iter_mut() {
        // Update agent perception based on world state
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Benefits:</strong></p>
<ul>
<li>Cache-friendly data layout</li>
<li>Parallel system execution</li>
<li>Clean separation of data and logic</li>
<li>Easy to reason about and test</li>
</ul>
<h2 id="the-ai-pipeline"><a class="header" href="#the-ai-pipeline">The AI Pipeline</a></h2>
<h3 id="1-perception-bus"><a class="header" href="#1-perception-bus">1. Perception Bus</a></h3>
<p>AI agents receive structured snapshots of the world state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct PerceptionSnapshot {
    pub timestamp: u64,
    pub agent_id: EntityId,
    pub visible_entities: Vec&lt;EntityData&gt;,
    pub audio_events: Vec&lt;AudioEvent&gt;,
    pub world_state: WorldState,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Design Principles:</strong></p>
<ul>
<li><strong>Filtered Information</strong>: Agents only perceive what they should be able to see/hear</li>
<li><strong>Structured Data</strong>: JSON-serializable for easy AI model consumption</li>
<li><strong>Temporal Consistency</strong>: Snapshots include timing information</li>
<li><strong>Bandwidth Efficient</strong>: Only relevant changes are included</li>
</ul>
<h3 id="2-planning-layer"><a class="header" href="#2-planning-layer">2. Planning Layer</a></h3>
<p>AI models generate plans using the perception data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AIPlan {
    pub agent_id: EntityId,
    pub intent: Intent,
    pub tools: Vec&lt;ToolUsage&gt;,
    pub confidence: f32,
    pub reasoning: String, // For debugging and learning
}

pub enum Intent {
    MoveTo { target: Vec3, urgency: f32 },
    AttackTarget { target: EntityId, weapon: Option&lt;EntityId&gt; },
    Interact { target: EntityId, interaction_type: String },
    Communicate { target: EntityId, message: String },
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>High-Level Intents</strong>: AI thinks in terms of goals, not implementation</li>
<li><strong>Tool-Based Actions</strong>: All actions go through validated tools</li>
<li><strong>Confidence Scoring</strong>: Enables dynamic difficulty and behavior tuning</li>
<li><strong>Explainable Reasoning</strong>: For debugging and player understanding</li>
</ul>
<h3 id="3-tool-validation"><a class="header" href="#3-tool-validation">3. Tool Validation</a></h3>
<p>Every AI action must be validated by the engine:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Tool {
    fn validate(&amp;self, world: &amp;World, usage: &amp;ToolUsage) -&gt; ValidationResult;
    fn execute(&amp;self, world: &amp;mut World, usage: &amp;ToolUsage) -&gt; ExecutionResult;
}

// Example: Movement tool
impl Tool for MovementTool {
    fn validate(&amp;self, world: &amp;World, usage: &amp;ToolUsage) -&gt; ValidationResult {
        let agent = world.get::&lt;Position&gt;(usage.agent_id)?;
        let target = usage.target_position;
        
        // Check line of sight
        if !world.line_of_sight(agent.0, target) {
            return ValidationResult::Blocked(BlockReason::LineOfSight);
        }
        
        // Check movement cooldown
        if !self.cooldown_ready(usage.agent_id) {
            return ValidationResult::Blocked(BlockReason::Cooldown);
        }
        
        ValidationResult::Valid
    }
    
    fn execute(&amp;self, world: &amp;mut World, usage: &amp;ToolUsage) -&gt; ExecutionResult {
        // Actually perform the movement
        world.get_mut::&lt;Position&gt;(usage.agent_id)?.0 = usage.target_position;
        ExecutionResult::Success
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Validation Categories:</strong></p>
<ul>
<li><strong>Physics Constraints</strong>: Can the action physically happen?</li>
<li><strong>Resource Requirements</strong>: Does the agent have what's needed?</li>
<li><strong>Cooldowns</strong>: Is the action available now?</li>
<li><strong>Line of Sight</strong>: Can the agent see the target?</li>
<li><strong>Game Rules</strong>: Does this follow the game's rules?</li>
</ul>
<h2 id="networking-architecture"><a class="header" href="#networking-architecture">Networking Architecture</a></h2>
<h3 id="server-authority"><a class="header" href="#server-authority">Server Authority</a></h3>
<p>AstraWeave uses server-authoritative validation for multiplayer:</p>
<pre><code>Client AI ‚Üí Intent ‚Üí Server Validation ‚Üí World Update ‚Üí State Broadcast
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>No client-side cheating possible</li>
<li>Consistent world state across all clients</li>
<li>AI agents validated same as human players</li>
<li>Deterministic simulation enables easy rollback</li>
</ul>
<h3 id="intent-replication"><a class="header" href="#intent-replication">Intent Replication</a></h3>
<p>Instead of replicating low-level actions, AstraWeave replicates high-level intents:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct NetworkIntent {
    pub player_id: PlayerId,
    pub intent: Intent,
    pub timestamp: u64,
    pub predicted_outcome: Option&lt;PredictedResult&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Lower bandwidth than action replication</li>
<li>Natural lag compensation through prediction</li>
<li>AI and human intents handled identically</li>
<li>Easy to implement anti-cheat</li>
</ul>
<h2 id="performance-architecture"><a class="header" href="#performance-architecture">Performance Architecture</a></h2>
<h3 id="cpu-performance"><a class="header" href="#cpu-performance">CPU Performance</a></h3>
<ul>
<li><strong>ECS Archetype Iteration</strong>: Cache-friendly component access</li>
<li><strong>Parallel Systems</strong>: Independent systems run in parallel</li>
<li><strong>Incremental Updates</strong>: Only changed data is processed</li>
<li><strong>Fixed Timestep</strong>: Predictable CPU load</li>
</ul>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<ul>
<li><strong>Pool Allocation</strong>: Entities and components use object pools</li>
<li><strong>Streaming</strong>: World chunks loaded/unloaded based on relevance</li>
<li><strong>Compression</strong>: Perception data compressed before AI processing</li>
<li><strong>Garbage Collection</strong>: Minimal allocations in hot paths</li>
</ul>
<h3 id="gpu-utilization"><a class="header" href="#gpu-utilization">GPU Utilization</a></h3>
<ul>
<li><strong>Deferred Rendering</strong>: Efficient handling of many lights</li>
<li><strong>Instanced Rendering</strong>: Batch similar objects</li>
<li><strong>Compute Shaders</strong>: Physics and AI calculations on GPU</li>
<li><strong>Temporal Upsampling</strong>: Maintain quality at lower resolution</li>
</ul>
<h2 id="modularity-and-extensibility"><a class="header" href="#modularity-and-extensibility">Modularity and Extensibility</a></h2>
<h3 id="crate-organization"><a class="header" href="#crate-organization">Crate Organization</a></h3>
<pre><code>astraweave-core/     # ECS, validation, core types
astraweave-ai/       # AI planning and perception
astraweave-physics/  # Physics integration
astraweave-render/   # Rendering pipeline
astraweave-audio/    # Audio system
astraweave-nav/      # Navigation and pathfinding
astraweave-net/      # Networking layer
</code></pre>
<h3 id="plugin-system"><a class="header" href="#plugin-system">Plugin System</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait EnginePlugin {
    fn build(&amp;self, app: &amp;mut App);
}

pub struct CustomGamePlugin;

impl EnginePlugin for CustomGamePlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_system(custom_ai_behavior_system)
           .add_tool(CustomInteractionTool)
           .register_component::&lt;CustomComponent&gt;();
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<h3 id="ai-sandboxing"><a class="header" href="#ai-sandboxing">AI Sandboxing</a></h3>
<p>AI agents cannot:</p>
<ul>
<li>Access arbitrary memory</li>
<li>Execute arbitrary code</li>
<li>Bypass tool validation</li>
<li>Affect systems outside their permissions</li>
</ul>
<p>AI agents can only:</p>
<ul>
<li>Receive perception data</li>
<li>Generate high-level intents</li>
<li>Use validated tools</li>
<li>Learn from feedback</li>
</ul>
<h3 id="deterministic-security"><a class="header" href="#deterministic-security">Deterministic Security</a></h3>
<p>The deterministic simulation enables:</p>
<ul>
<li><strong>Replay Verification</strong>: Detect desync and cheating</li>
<li><strong>Formal Verification</strong>: Mathematical proof of certain properties</li>
<li><strong>Predictable Testing</strong>: Reliable automated testing</li>
<li><strong>Audit Trails</strong>: Complete history of all decisions</li>
</ul>
<h2 id="development-philosophy"><a class="header" href="#development-philosophy">Development Philosophy</a></h2>
<h3 id="composition-over-inheritance"><a class="header" href="#composition-over-inheritance">Composition Over Inheritance</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of inheritance hierarchies
class AIAgent extends Entity { ... }

// Use component composition
struct Entity {
    components: HashMap&lt;ComponentId, Box&lt;dyn Component&gt;&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="data-driven-design"><a class="header" href="#data-driven-design">Data-Driven Design</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Behavior configured through data
#[derive(Deserialize)]
struct AIProfile {
    aggression: f32,
    curiosity: f32,
    risk_tolerance: f32,
    preferred_tools: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testable-architecture"><a class="header" href="#testable-architecture">Testable Architecture</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Every system is pure and testable
fn ai_planning_system(
    world: &amp;World, 
    perceptions: &amp;[PerceptionSnapshot]
) -&gt; Vec&lt;AIPlan&gt; {
    // Pure function - easy to test
}
<span class="boring">}</span></code></pre></pre>
<h2 id="comparison-with-traditional-engines"><a class="header" href="#comparison-with-traditional-engines">Comparison with Traditional Engines</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traditional Engine</th><th>AstraWeave</th></tr></thead><tbody>
<tr><td>AI Integration</td><td>Bolted-on scripting</td><td>Core architecture</td></tr>
<tr><td>Action Validation</td><td>Trust-based</td><td>Engine-validated</td></tr>
<tr><td>Determinism</td><td>Variable</td><td>Fixed-tick</td></tr>
<tr><td>Networking</td><td>Action replication</td><td>Intent replication</td></tr>
<tr><td>Performance</td><td>Variable</td><td>Predictable</td></tr>
<tr><td>Testing</td><td>Difficult</td><td>Deterministic</td></tr>
</tbody></table>
</div>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>To understand specific systems:</p>
<ul>
<li><a href="architecture/./ai-native.html">AI-Native Design</a> - Deep dive into AI architecture</li>
<li><a href="architecture/./ecs.html">ECS Architecture</a> - Entity-Component-System details</li>
<li><a href="architecture/./deterministic.html">Deterministic Simulation</a> - Fixed-tick simulation</li>
<li><a href="architecture/./tool-validation.html">Tool Validation System</a> - How AI actions are validated</li>
</ul>
<p>To start building:</p>
<ul>
<li><a href="architecture/../game-dev/first-game.html">Building Your First Game</a></li>
<li><a href="architecture/../core-systems/ai/index.html">Core Systems</a></li>
<li><a href="architecture/../examples/index.html">Working Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai-native-design"><a class="header" href="#ai-native-design">AI-Native Design</a></h1>
<p>AstraWeave's AI-native design represents a fundamental shift in how game engines approach artificial intelligence. Instead of treating AI as an add-on feature, we've built the entire engine around the principle that <strong>AI agents are first-class citizens</strong>.</p>
<h2 id="the-traditional-approach-and-why-it-fails"><a class="header" href="#the-traditional-approach-and-why-it-fails">The Traditional Approach (And Why It Fails)</a></h2>
<p>Most game engines follow this pattern:</p>
<pre><code>Game Engine ‚Üí Game Logic ‚Üí AI Scripting Layer ‚Üí NPC Behaviors
</code></pre>
<p><strong>Problems with this approach:</strong></p>
<ul>
<li>AI is disconnected from core game systems</li>
<li>AI agents can cheat (access hidden information, ignore physics)</li>
<li>Difficult to create consistent multiplayer behavior</li>
<li>AI behavior is scripted, not emergent</li>
<li>Hard to test and debug AI interactions</li>
</ul>
<h2 id="astraweaves-ai-native-approach"><a class="header" href="#astraweaves-ai-native-approach">AstraWeave's AI-Native Approach</a></h2>
<p>AstraWeave inverts this relationship:</p>
<pre><code>AI Agents ‚Üê Tool Validation ‚Üê Engine Core ‚Üê Game Logic
</code></pre>
<p><strong>Benefits of this approach:</strong></p>
<ul>
<li>AI and human players use identical systems</li>
<li>No AI cheating possible</li>
<li>Emergent behavior from simple rules</li>
<li>Natural multiplayer compatibility</li>
<li>Testable and debuggable AI behavior</li>
</ul>
<h2 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h2>
<h3 id="1-perception-based-decision-making"><a class="header" href="#1-perception-based-decision-making">1. Perception-Based Decision Making</a></h3>
<p>AI agents only know what they can perceive:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct PerceptionSnapshot {
    // Only information the AI should have access to
    pub visible_entities: Vec&lt;EntityData&gt;,
    pub audible_events: Vec&lt;AudioEvent&gt;,
    pub remembered_information: Vec&lt;MemoryItem&gt;,
    pub world_constraints: Vec&lt;Constraint&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>No omniscience</strong>: AI cannot access:</p>
<ul>
<li>Hidden game state</li>
<li>Other agents' thoughts</li>
<li>Perfect world information</li>
<li>Player UI state</li>
<li>Debug information</li>
</ul>
<p><strong>Realistic limitations</strong>: AI must work within:</p>
<ul>
<li>Line of sight restrictions</li>
<li>Hearing range limitations</li>
<li>Memory capacity constraints</li>
<li>Processing time limits</li>
</ul>
<h3 id="2-intent-based-actions"><a class="header" href="#2-intent-based-actions">2. Intent-Based Actions</a></h3>
<p>AI generates high-level intents, not low-level commands:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Intent {
    // High-level goals
    ExploreArea { target_region: Region, curiosity: f32 },
    SeekCover { threat_direction: Vec3, urgency: f32 },
    ProtectAlly { ally_id: EntityId, commitment: f32 },
    
    // Not low-level commands like "move left 3 pixels"
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>AI thinks strategically, not tactically</li>
<li>Natural language mapping for LLMs</li>
<li>Easy to understand and debug</li>
<li>Platform and implementation independent</li>
</ul>
<h3 id="3-tool-based-execution"><a class="header" href="#3-tool-based-execution">3. Tool-Based Execution</a></h3>
<p>All AI actions go through validated tools:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Tool {
    // Every action must be validated first
    fn validate(&amp;self, world: &amp;World, usage: &amp;ToolUsage) -&gt; ValidationResult;
    
    // Only valid actions are executed
    fn execute(&amp;self, world: &amp;mut World, usage: &amp;ToolUsage) -&gt; ExecutionResult;
    
    // Tools have constraints and cooldowns
    fn get_constraints(&amp;self) -&gt; ToolConstraints;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>No direct world manipulation</strong>: AI cannot:</p>
<ul>
<li>Teleport entities</li>
<li>Spawn infinite resources</li>
<li>Ignore physics constraints</li>
<li>Break game rules</li>
</ul>
<h2 id="the-ai-pipeline-architecture"><a class="header" href="#the-ai-pipeline-architecture">The AI Pipeline Architecture</a></h2>
<h3 id="phase-1-perception"><a class="header" href="#phase-1-perception">Phase 1: Perception</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn perception_system(
    mut agents: Query&lt;(&amp;Position, &amp;AIAgent, &amp;mut PerceptionState)&gt;,
    world_entities: Query&lt;&amp;Position, &amp;EntityType&gt;,
    audio_events: Res&lt;AudioEventBuffer&gt;,
) {
    for (pos, agent, mut perception) in agents.iter_mut() {
        let mut snapshot = PerceptionSnapshot::new();
        
        // Gather visible entities (line of sight)
        for (other_pos, entity_type) in world_entities.iter() {
            if world.line_of_sight(pos.0, other_pos.0) {
                let distance = pos.0.distance(other_pos.0);
                if distance &lt;= agent.vision_range {
                    snapshot.visible_entities.push(EntityData {
                        position: other_pos.0,
                        entity_type: entity_type.clone(),
                        distance,
                    });
                }
            }
        }
        
        // Gather audible events
        for event in audio_events.iter() {
            let distance = pos.0.distance(event.position);
            let volume = event.calculate_volume_at_distance(distance);
            if volume &gt; agent.hearing_threshold {
                snapshot.audible_events.push(event.clone());
            }
        }
        
        // Include relevant memories
        snapshot.remembered_information = agent.memory.query_relevant(
            &amp;snapshot, 
            agent.memory_capacity
        );
        
        perception.current_snapshot = Some(snapshot);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="phase-2-planning"><a class="header" href="#phase-2-planning">Phase 2: Planning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ai_planning_system(
    mut agents: Query&lt;(&amp;AIAgent, &amp;PerceptionState, &amp;mut PlanningState)&gt;,
    ai_service: Res&lt;AIService&gt;,
) {
    for (agent, perception, mut planning) in agents.iter_mut() {
        if let Some(snapshot) = &amp;perception.current_snapshot {
            // Prepare input for AI model
            let planning_request = PlanningRequest {
                agent_profile: agent.profile.clone(),
                perception_data: snapshot.clone(),
                available_tools: tool_registry.get_available_tools(agent.id),
                current_goals: agent.goal_stack.clone(),
                recent_memory: agent.memory.get_recent(10),
            };
            
            // Generate plan using LLM
            match ai_service.generate_plan(planning_request) {
                Ok(plan) =&gt; {
                    info!("AI generated plan: {:?}", plan);
                    planning.current_plan = Some(plan);
                },
                Err(e) =&gt; {
                    warn!("AI planning failed: {}", e);
                    // Fallback to simple behaviors
                    planning.current_plan = Some(generate_fallback_plan(agent));
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="phase-3-validation"><a class="header" href="#phase-3-validation">Phase 3: Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tool_validation_system(
    mut agents: Query&lt;(&amp;PlanningState, &amp;mut ActionQueue)&gt;,
    tool_registry: Res&lt;ToolRegistry&gt;,
    world: &amp;World,
) {
    for (planning, mut actions) in agents.iter_mut() {
        if let Some(plan) = &amp;planning.current_plan {
            for tool_usage in &amp;plan.tool_usages {
                let tool = tool_registry.get_tool(&amp;tool_usage.tool_name)?;
                
                match tool.validate(world, tool_usage) {
                    ValidationResult::Valid =&gt; {
                        actions.push(ValidatedAction {
                            tool_usage: tool_usage.clone(),
                            validation_timestamp: world.current_tick(),
                        });
                    },
                    ValidationResult::Blocked(reason) =&gt; {
                        warn!("Tool validation failed: {:?}", reason);
                        // AI learns from failure
                        agent.memory.record_failure(tool_usage, reason);
                    },
                    ValidationResult::Delayed(wait_time) =&gt; {
                        actions.push_delayed(tool_usage.clone(), wait_time);
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="phase-4-execution"><a class="header" href="#phase-4-execution">Phase 4: Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn action_execution_system(
    mut agents: Query&lt;&amp;mut ActionQueue&gt;,
    tool_registry: Res&lt;ToolRegistry&gt;,
    mut world: ResMut&lt;World&gt;,
) {
    for mut actions in agents.iter_mut() {
        while let Some(action) = actions.pop_ready() {
            let tool = tool_registry.get_tool(&amp;action.tool_usage.tool_name)?;
            
            match tool.execute(&amp;mut world, &amp;action.tool_usage) {
                ExecutionResult::Success =&gt; {
                    // AI learns from success
                    agent.memory.record_success(&amp;action.tool_usage);
                },
                ExecutionResult::Failed(reason) =&gt; {
                    // Even validated actions can fail during execution
                    warn!("Action execution failed: {:?}", reason);
                    agent.memory.record_execution_failure(&amp;action.tool_usage, reason);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="tool-design-philosophy"><a class="header" href="#tool-design-philosophy">Tool Design Philosophy</a></h2>
<h3 id="tools-as-affordances"><a class="header" href="#tools-as-affordances">Tools as Affordances</a></h3>
<p>In AstraWeave, tools represent what an agent <em>can do</em>, not what it <em>will do</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MovementTool {
    max_speed: f32,
    acceleration: f32,
    valid_surfaces: Vec&lt;SurfaceType&gt;,
}

impl Tool for MovementTool {
    fn validate(&amp;self, world: &amp;World, usage: &amp;ToolUsage) -&gt; ValidationResult {
        // Check if movement is physically possible
        let agent_pos = world.get::&lt;Position&gt;(usage.agent_id)?;
        let target_pos = usage.parameters.get_vec3("target")?;
        
        // Line of sight check
        if !world.line_of_sight(agent_pos.0, target_pos) {
            return ValidationResult::Blocked(BlockReason::ObstructedPath);
        }
        
        // Surface validity check
        let surface_type = world.get_surface_type(target_pos);
        if !self.valid_surfaces.contains(&amp;surface_type) {
            return ValidationResult::Blocked(BlockReason::InvalidSurface);
        }
        
        // Speed limit check
        let distance = agent_pos.0.distance(target_pos);
        let time_required = distance / self.max_speed;
        if time_required &gt; usage.max_execution_time {
            return ValidationResult::Blocked(BlockReason::TooSlow);
        }
        
        ValidationResult::Valid
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tool-composition"><a class="header" href="#tool-composition">Tool Composition</a></h3>
<p>Complex behaviors emerge from combining simple tools:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AI plans using multiple tools in sequence
let complex_plan = AIPlan {
    steps: vec![
        ToolUsage {
            tool_name: "MovementTool",
            parameters: movement_params,
        },
        ToolUsage {
            tool_name: "InteractionTool", 
            parameters: interaction_params,
        },
        ToolUsage {
            tool_name: "CommunicationTool",
            parameters: communication_params,
        },
    ],
};
<span class="boring">}</span></code></pre></pre>
<h2 id="learning-and-adaptation"><a class="header" href="#learning-and-adaptation">Learning and Adaptation</a></h2>
<h3 id="memory-system-integration"><a class="header" href="#memory-system-integration">Memory System Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AIMemory {
    // Short-term working memory
    working_memory: VecDeque&lt;MemoryItem&gt;,
    
    // Long-term episodic memory
    episodic_memory: Vec&lt;Episode&gt;,
    
    // Learned patterns and strategies
    strategy_memory: HashMap&lt;Situation, Strategy&gt;,
    
    // Failed actions and why they failed
    failure_memory: Vec&lt;FailureRecord&gt;,
}

impl AIMemory {
    pub fn record_success(&amp;mut self, action: &amp;ToolUsage, outcome: &amp;ExecutionResult) {
        // Reinforce successful strategies
        let situation = self.extract_situation_features(action);
        let strategy = self.extract_strategy_features(action);
        self.strategy_memory.entry(situation)
            .or_default()
            .reinforce(strategy, outcome.success_metric());
    }
    
    pub fn record_failure(&amp;mut self, action: &amp;ToolUsage, reason: &amp;BlockReason) {
        // Learn from failures to avoid them
        self.failure_memory.push(FailureRecord {
            action: action.clone(),
            reason: reason.clone(),
            context: self.current_context.clone(),
            timestamp: Instant::now(),
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dynamic-behavior-adaptation"><a class="header" href="#dynamic-behavior-adaptation">Dynamic Behavior Adaptation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn adaptation_system(
    mut agents: Query&lt;(&amp;mut AIAgent, &amp;AIMemory)&gt;,
) {
    for (mut agent, memory) in agents.iter_mut() {
        // Adjust behavior based on recent experiences
        let recent_failures = memory.get_recent_failures(Duration::from_secs(300));
        
        if recent_failures.iter().any(|f| matches!(f.reason, BlockReason::TooAggressive)) {
            agent.profile.aggression *= 0.9; // Become less aggressive
        }
        
        if recent_failures.iter().any(|f| matches!(f.reason, BlockReason::TooSlow)) {
            agent.profile.urgency *= 1.1; // Become more urgent
        }
        
        // Adapt strategy preferences
        let successful_strategies = memory.get_successful_strategies();
        for (situation, strategy) in successful_strategies {
            agent.strategy_preferences.insert(situation, strategy);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="emergent-behavior-examples"><a class="header" href="#emergent-behavior-examples">Emergent Behavior Examples</a></h2>
<h3 id="cooperative-pathfinding"><a class="header" href="#cooperative-pathfinding">Cooperative Pathfinding</a></h3>
<p>When multiple AI agents need to navigate through a narrow passage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// No explicit coordination code needed
// Emergent behavior arises from:
// 1. Each agent perceives others as obstacles
// 2. Movement tool validates non-collision
// 3. Agents naturally take turns or find alternate routes
<span class="boring">}</span></code></pre></pre>
<h3 id="dynamic-alliance-formation"><a class="header" href="#dynamic-alliance-formation">Dynamic Alliance Formation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Agents can form alliances based on shared threats
fn threat_response_planning(
    agent: &amp;AIAgent,
    perception: &amp;PerceptionSnapshot,
) -&gt; Intent {
    let threats = perception.identify_threats();
    let potential_allies = perception.identify_potential_allies();
    
    if threats.is_empty() {
        return Intent::Explore { target: random_area() };
    }
    
    if potential_allies.is_empty() {
        return Intent::Flee { threat_direction: threats[0].position };
    }
    
    // Emergent alliance formation
    Intent::CoordinateDefense {
        allies: potential_allies,
        threat: threats[0],
        strategy: choose_defensive_strategy(threats, potential_allies),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="adaptive-combat-tactics"><a class="header" href="#adaptive-combat-tactics">Adaptive Combat Tactics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AI learns and counters player strategies
fn combat_planning(
    agent: &amp;AIAgent,
    perception: &amp;PerceptionSnapshot,
    memory: &amp;AIMemory,
) -&gt; Intent {
    let player = perception.find_player()?;
    
    // Analyze player's recent tactics
    let player_patterns = memory.analyze_player_behavior(&amp;player);
    
    // Choose counter-strategy
    let counter_strategy = match player_patterns.primary_tactic {
        PlayerTactic::RushAttack =&gt; CombatStrategy::DefensiveCounter,
        PlayerTactic::RangedKiting =&gt; CombatStrategy::ClosingPincer,
        PlayerTactic::DefensiveTurtle =&gt; CombatStrategy::AreaDenial,
        PlayerTactic::Unpredictable =&gt; CombatStrategy::AdaptiveReactive,
    };
    
    Intent::ExecuteCombatStrategy {
        target: player.entity_id,
        strategy: counter_strategy,
        commitment: calculate_commitment(player_patterns.skill_level),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="computational-efficiency"><a class="header" href="#computational-efficiency">Computational Efficiency</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AI planning can be expensive, so we use various optimizations:

pub struct AIService {
    // LLM inference can be slow
    model_cache: LRUCache&lt;PlanningRequest, AIPlan&gt;,
    
    // Batch multiple planning requests
    batch_processor: BatchProcessor&lt;PlanningRequest&gt;,
    
    // Use cheaper models for simple decisions
    model_hierarchy: Vec&lt;AIModel&gt;, // Fast ‚Üí Accurate
}

impl AIService {
    pub fn generate_plan(&amp;self, request: PlanningRequest) -&gt; Result&lt;AIPlan&gt; {
        // Check cache first
        if let Some(cached_plan) = self.model_cache.get(&amp;request) {
            return Ok(cached_plan.clone());
        }
        
        // Use appropriate model based on complexity
        let model = self.select_model(request.complexity());
        
        // Generate plan
        let plan = model.generate_plan(request)?;
        
        // Cache result
        self.model_cache.insert(request, plan.clone());
        
        Ok(plan)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AI memory systems need careful management
impl AIMemory {
    pub fn cleanup_old_memories(&amp;mut self) {
        // Remove memories older than threshold
        let cutoff = Instant::now() - Duration::from_secs(3600); // 1 hour
        self.episodic_memory.retain(|episode| episode.timestamp &gt; cutoff);
        
        // Compress similar memories
        self.compress_similar_episodes();
        
        // Keep only the most important failures
        self.failure_memory.sort_by_key(|f| f.importance_score());
        self.failure_memory.truncate(100); // Keep top 100
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-ai-behavior"><a class="header" href="#debugging-ai-behavior">Debugging AI Behavior</a></h2>
<h3 id="explainable-ai"><a class="header" href="#explainable-ai">Explainable AI</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize)]
pub struct AIPlan {
    pub intent: Intent,
    pub reasoning: String, // Natural language explanation
    pub confidence: f32,
    pub alternative_plans: Vec&lt;AlternativePlan&gt;,
    pub decision_factors: Vec&lt;DecisionFactor&gt;,
}

// Example reasoning output:
"I can see an enemy at position (10, 5) who appears to be low on health. 
My ally is engaged in combat nearby and could use support. I have a clear 
line of sight and my weapon is ready. I'm choosing to attack rather than 
flank because the enemy seems focused on my ally and won't see me coming."
<span class="boring">}</span></code></pre></pre>
<h3 id="debug-visualization"><a class="header" href="#debug-visualization">Debug Visualization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In development builds, expose AI decision making
#[cfg(debug_assertions)]
impl AIAgent {
    pub fn get_debug_info(&amp;self) -&gt; AIDebugInfo {
        AIDebugInfo {
            current_perception: self.perception.clone(),
            active_plan: self.planning.current_plan.clone(),
            recent_decisions: self.memory.get_recent_decisions(10),
            personality_state: self.profile.clone(),
            tool_availability: self.get_available_tools(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-traditional-game-systems"><a class="header" href="#integration-with-traditional-game-systems">Integration with Traditional Game Systems</a></h2>
<h3 id="physics-integration"><a class="header" href="#physics-integration">Physics Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AI respects physics constraints
impl Tool for MovementTool {
    fn validate(&amp;self, world: &amp;World, usage: &amp;ToolUsage) -&gt; ValidationResult {
        let physics_world = world.resource::&lt;PhysicsWorld&gt;();
        let agent_body = physics_world.get_body(usage.agent_id)?;
        
        // Check if movement would cause collision
        let proposed_movement = usage.parameters.get_vec3("target")?;
        if physics_world.would_collide(agent_body, proposed_movement) {
            return ValidationResult::Blocked(BlockReason::PhysicsCollision);
        }
        
        ValidationResult::Valid
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="animation-integration"><a class="header" href="#animation-integration">Animation Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AI actions trigger appropriate animations
impl Tool for CombatTool {
    fn execute(&amp;self, world: &amp;mut World, usage: &amp;ToolUsage) -&gt; ExecutionResult {
        let attack_type = usage.parameters.get_string("attack_type")?;
        
        // Trigger combat animation
        world.get_mut::&lt;AnimationController&gt;(usage.agent_id)?
             .play_animation(format!("attack_{}", attack_type));
        
        // Execute combat logic
        self.resolve_combat(world, usage)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="comparison-traditional-vs-ai-native"><a class="header" href="#comparison-traditional-vs-ai-native">Comparison: Traditional vs AI-Native</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traditional Approach</th><th>AstraWeave AI-Native</th></tr></thead><tbody>
<tr><td><strong>Decision Making</strong></td><td>Scripted state machines</td><td>LLM-based planning</td></tr>
<tr><td><strong>World Knowledge</strong></td><td>Omniscient access</td><td>Perception-limited</td></tr>
<tr><td><strong>Action Execution</strong></td><td>Direct world manipulation</td><td>Tool-validated actions</td></tr>
<tr><td><strong>Behavior Adaptation</strong></td><td>Manual script updates</td><td>Automatic learning</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>Separate AI/player code</td><td>Unified validation</td></tr>
<tr><td><strong>Debugging</strong></td><td>Complex state inspection</td><td>Natural language reasoning</td></tr>
<tr><td><strong>Performance</strong></td><td>Predictable overhead</td><td>Variable AI complexity</td></tr>
<tr><td><strong>Emergence</strong></td><td>Limited by scripts</td><td>Unbounded combinations</td></tr>
</tbody></table>
</div>
<h2 id="best-practices-for-ai-native-development"><a class="header" href="#best-practices-for-ai-native-development">Best Practices for AI-Native Development</a></h2>
<h3 id="1-design-affordances-not-behaviors"><a class="header" href="#1-design-affordances-not-behaviors">1. Design Affordances, Not Behaviors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Define what an agent CAN do
pub struct InteractionTool {
    pub interaction_range: f32,
    pub valid_targets: Vec&lt;EntityType&gt;,
    pub cooldown: Duration,
}

// Avoid: Scripting what an agent WILL do
// pub fn npc_behavior_script() { ... }
<span class="boring">}</span></code></pre></pre>
<h3 id="2-embrace-failure-as-learning"><a class="header" href="#2-embrace-failure-as-learning">2. Embrace Failure as Learning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AI failures are features, not bugs
if let Err(validation_error) = tool.validate(world, usage) {
    // Don't just log the error - let the AI learn from it
    agent.memory.record_lesson(validation_error, current_context);
    
    // AI will avoid this mistake in similar situations
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-provide-rich-perception"><a class="header" href="#3-provide-rich-perception">3. Provide Rich Perception</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Give AI agents the information they need to make good decisions
pub struct PerceptionSnapshot {
    // Not just positions, but meaningful context
    pub entities: Vec&lt;EntityPerception&gt;,
    pub environmental_cues: Vec&lt;EnvironmentalCue&gt;,
    pub social_context: SocialContext,
    pub recent_events: Vec&lt;GameEvent&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-use-hierarchical-planning"><a class="header" href="#4-use-hierarchical-planning">4. Use Hierarchical Planning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Break complex goals into manageable sub-goals
pub enum Intent {
    // High-level strategic goals
    DefendTerritory { area: Region },
    
    // Mid-level tactical goals  
    EstablishDefensivePosition { chokepoint: Vec3 },
    
    // Low-level operational goals
    MoveToCover { cover_position: Vec3 },
}
<span class="boring">}</span></code></pre></pre>
<h2 id="future-directions"><a class="header" href="#future-directions">Future Directions</a></h2>
<h3 id="advanced-ai-architectures"><a class="header" href="#advanced-ai-architectures">Advanced AI Architectures</a></h3>
<ul>
<li><strong>Multi-Agent Planning</strong>: Coordinated group decision making</li>
<li><strong>Hierarchical Temporal Memory</strong>: Better long-term memory systems</li>
<li><strong>Causal Reasoning</strong>: Understanding cause-and-effect relationships</li>
<li><strong>Meta-Learning</strong>: AI that learns how to learn better</li>
</ul>
<h3 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h3>
<ul>
<li><strong>Neural Network Compression</strong>: Smaller, faster AI models</li>
<li><strong>Predictive Caching</strong>: Pre-compute likely AI decisions</li>
<li><strong>Distributed Processing</strong>: AI planning across multiple cores/machines</li>
<li><strong>Hybrid Approaches</strong>: Combine neural networks with symbolic reasoning</li>
</ul>
<hr />
<p><em>AI-native design is not just about making NPCs smarter - it's about creating fundamentally new types of interactive experiences where AI agents are true participants in the game world, subject to the same rules and constraints as human players.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecs-architecture"><a class="header" href="#ecs-architecture">ECS Architecture</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deterministic-simulation"><a class="header" href="#deterministic-simulation">Deterministic Simulation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tool-validation-system"><a class="header" href="#tool-validation-system">Tool Validation System</a></h1>
<p>The AstraWeave LLM integration includes a comprehensive tool validation system that ensures LLM-generated plans are safe and comply with the game's allowed actions.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The tool validation system works in three layers:</p>
<ol>
<li><strong>Schema Validation</strong>: Ensures JSON structure matches expected format</li>
<li><strong>Tool Registry Validation</strong>: Verifies all actions are in the allowed tool set</li>
<li><strong>Engine Validation</strong>: Runtime checks for cooldowns, line-of-sight, and other constraints</li>
</ol>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<h3 id="toolregistry"><a class="header" href="#toolregistry">ToolRegistry</a></h3>
<p>The <code>ToolRegistry</code> defines which tools are available to the LLM:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ToolRegistry {
    pub tools: Vec&lt;ToolSpec&gt;,
    pub constraints: Constraints,
}

pub struct ToolSpec {
    pub name: String,
    pub args: BTreeMap&lt;String, String&gt;, // argument name -&gt; type
}
<span class="boring">}</span></code></pre></pre>
<h3 id="validation-process"><a class="header" href="#validation-process">Validation Process</a></h3>
<ol>
<li><strong>LLM Response Parsing</strong>: Parse the JSON response into a <code>PlanIntent</code></li>
<li><strong>Tool Allowlist Check</strong>: Verify each action is in the registry</li>
<li><strong>Type Validation</strong>: Ensure arguments match expected types (future enhancement)</li>
<li><strong>Runtime Validation</strong>: Engine checks constraints during execution</li>
</ol>
<h3 id="supported-actions"><a class="header" href="#supported-actions">Supported Actions</a></h3>
<ul>
<li><strong>MoveTo</strong>: Move companion to specified coordinates</li>
<li><strong>Throw</strong>: Throw items (smoke, grenade) at target location</li>
<li><strong>CoverFire</strong>: Provide covering fire at target for duration</li>
<li><strong>Revive</strong>: Revive allied units</li>
</ul>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>The system provides clear error messages for validation failures:</p>
<ul>
<li>Invalid JSON format</li>
<li>Disallowed tools used by LLM</li>
<li>Missing required arguments</li>
<li>Type mismatches (future)</li>
</ul>
<h3 id="security-features"><a class="header" href="#security-features">Security Features</a></h3>
<ul>
<li><strong>Allowlist-only</strong>: Only pre-approved actions can be executed</li>
<li><strong>No dynamic code execution</strong>: All actions are statically defined</li>
<li><strong>Input sanitization</strong>: JSON parsing prevents injection attacks</li>
<li><strong>Constraint enforcement</strong>: Runtime validation prevents illegal moves</li>
</ul>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use astraweave_llm::{parse_llm_plan, MockLlm, plan_from_llm};

// Create tool registry
let registry = ToolRegistry {
    tools: vec![
        ToolSpec {
            name: "move_to".into(),
            args: [("x", "i32"), ("y", "i32")].into_iter().collect(),
        }
    ],
    constraints: Constraints::default(),
};

// Parse and validate LLM response
let plan = parse_llm_plan(llm_response, &amp;registry)?;

// Full end-to-end validation
let plan = plan_from_llm(&amp;client, &amp;world_snapshot, &amp;registry).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The validation system includes comprehensive tests covering:</p>
<ul>
<li>Valid plan parsing</li>
<li>Invalid JSON handling</li>
<li>Disallowed tool detection</li>
<li>Empty plan handling</li>
<li>All action types</li>
<li>Error message verification</li>
</ul>
<p>Run tests with:</p>
<pre><code class="language-bash">cargo test -p astraweave-llm
</code></pre>
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<ul>
<li>Argument type validation</li>
<li>Parameter range checking</li>
<li>Cost/resource validation</li>
<li>Complex constraint evaluation</li>
<li>Custom validation plugins</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai-system"><a class="header" href="#ai-system">AI System</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="perception-bus"><a class="header" href="#perception-bus">Perception Bus</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="planning-layer"><a class="header" href="#planning-layer">Planning Layer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tool-sandbox"><a class="header" href="#tool-sandbox">Tool Sandbox</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavior-trees"><a class="header" href="#behavior-trees">Behavior Trees</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics"><a class="header" href="#physics">Physics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio"><a class="header" href="#audio">Audio</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigation"><a class="header" href="#navigation">Navigation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-system"><a class="header" href="#input-system">Input System</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking"><a class="header" href="#networking">Networking</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-your-first-game"><a class="header" href="#building-your-first-game">Building Your First Game</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai-companions"><a class="header" href="#ai-companions">AI Companions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adaptive-bosses"><a class="header" href="#adaptive-bosses">Adaptive Bosses</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crafting--combat"><a class="header" href="#crafting--combat">Crafting &amp; Combat</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dialogue-systems"><a class="header" href="#dialogue-systems">Dialogue Systems</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedural-content"><a class="header" href="#procedural-content">Procedural Content</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-examples"><a class="header" href="#working-examples">Working Examples</a></h1>
<p>AstraWeave includes over 20 examples demonstrating different aspects of the engine. This page focuses on the <strong>working examples</strong> that you can build and run to learn the engine.</p>
<blockquote>
<p><strong>Note</strong>: AstraWeave is under active development. Some examples have compilation issues due to API evolution. This page focuses on examples that are confirmed to work.</p>
</blockquote>
<h2 id="core-ai-examples"><a class="header" href="#core-ai-examples">Core AI Examples</a></h2>
<p>These examples demonstrate the AI-native architecture:</p>
<h3 id="hello-companion-"><a class="header" href="#hello-companion-">Hello Companion ‚úÖ</a></h3>
<p><strong>Location</strong>: <code>examples/hello_companion</code><br />
<strong>Status</strong>: ‚úÖ Working (expected panic)</p>
<p>The simplest example of AI perception, planning, and validation.</p>
<pre><code class="language-bash">cargo run -p hello_companion --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>AI perception system capturing world state</li>
<li>LLM-based planning generating intents</li>
<li>Tool validation system (demonstrates failure case)</li>
<li>Fixed-tick simulation loop</li>
</ul>
<p><strong>Expected behavior</strong>: Shows AI plan generation, then panics with "LosBlocked" error. This demonstrates that the AI cannot perform invalid actions.</p>
<p><a href="examples/./hello-companion.html">‚Üí Detailed walkthrough</a></p>
<h3 id="adaptive-boss-"><a class="header" href="#adaptive-boss-">Adaptive Boss ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/adaptive_boss</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Multi-phase boss that adapts its strategy based on player behavior.</p>
<pre><code class="language-bash">cargo run -p adaptive_boss --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>Director system for complex AI behavior</li>
<li>Phase-based AI state machines</li>
<li>Dynamic strategy adaptation</li>
<li>Boss pattern recognition</li>
</ul>
<h3 id="companion-profile-"><a class="header" href="#companion-profile-">Companion Profile ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/companion_profile</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Demonstrates persistent AI profiles that learn and adapt.</p>
<pre><code class="language-bash">cargo run -p companion_profile --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>AI profile serialization/deserialization</li>
<li>Learning from player interactions</li>
<li>Personality trait adjustment</li>
<li>Long-term memory systems</li>
</ul>
<h2 id="core-engine-examples"><a class="header" href="#core-engine-examples">Core Engine Examples</a></h2>
<p>These examples showcase fundamental engine systems:</p>
<h3 id="physics-demo-3d-"><a class="header" href="#physics-demo-3d-">Physics Demo 3D ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/physics_demo3d</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Demonstrates the Rapier3D physics integration.</p>
<pre><code class="language-bash">cargo run -p physics_demo3d --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>3D physics simulation</li>
<li>Character controller integration</li>
<li>Collision detection and response</li>
<li>Physics-based AI movement</li>
</ul>
<h3 id="navmesh-demo-"><a class="header" href="#navmesh-demo-">Navmesh Demo ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/navmesh_demo</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Shows navigation mesh generation and pathfinding.</p>
<pre><code class="language-bash">cargo run -p navmesh_demo --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>Automatic navmesh generation</li>
<li>A* pathfinding</li>
<li>Dynamic obstacle avoidance</li>
<li>AI navigation coordination</li>
</ul>
<h3 id="audio-spatial-demo-"><a class="header" href="#audio-spatial-demo-">Audio Spatial Demo ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/audio_spatial_demo</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Spatial audio system with 3D positioning.</p>
<pre><code class="language-bash">cargo run -p audio_spatial_demo --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>3D positional audio</li>
<li>Dynamic audio sources</li>
<li>Environmental audio effects</li>
<li>Audio-based AI perception</li>
</ul>
<h2 id="networking-examples"><a class="header" href="#networking-examples">Networking Examples</a></h2>
<p>These examples show multiplayer and IPC capabilities:</p>
<h3 id="ipc-loopback-"><a class="header" href="#ipc-loopback-">IPC Loopback ‚úÖ</a></h3>
<p><strong>Location</strong>: <code>examples/ipc_loopback</code><br />
<strong>Status</strong>: ‚úÖ Should work</p>
<p>Demonstrates inter-process communication for AI models.</p>
<pre><code class="language-bash">cargo run -p ipc_loopback --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>Local/cloud AI model switching</li>
<li>Process isolation for AI</li>
<li>IPC message passing</li>
<li>AI model hot-swapping</li>
</ul>
<h3 id="coop-serverclient-"><a class="header" href="#coop-serverclient-">Coop Server/Client ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/coop_server</code>, <code>examples/coop_client</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Basic multiplayer client-server architecture.</p>
<pre><code class="language-bash"># Terminal 1
cargo run -p coop_server --release

# Terminal 2  
cargo run -p coop_client --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>Server-authoritative validation</li>
<li>Intent-based networking</li>
<li>AI agent synchronization</li>
<li>Anti-cheat through determinism</li>
</ul>
<h2 id="tool-and-planning-examples"><a class="header" href="#tool-and-planning-examples">Tool and Planning Examples</a></h2>
<p>These examples focus on AI planning and tool usage:</p>
<h3 id="llm-tool-call-"><a class="header" href="#llm-tool-call-">LLM Tool Call ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/llm_toolcall</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Direct demonstration of LLM tool calling.</p>
<pre><code class="language-bash">cargo run -p llm_toolcall --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>LLM integration</li>
<li>Tool definition and usage</li>
<li>Structured AI responses</li>
<li>Planning validation</li>
</ul>
<h3 id="phase-director-"><a class="header" href="#phase-director-">Phase Director ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/phase_director</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Complex AI director managing multiple phases.</p>
<pre><code class="language-bash">cargo run -p phase_director --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>Multi-phase AI behavior</li>
<li>Director pattern implementation</li>
<li>State machine management</li>
<li>Complex AI coordination</li>
</ul>
<h2 id="development-examples"><a class="header" href="#development-examples">Development Examples</a></h2>
<p>These examples help with engine development:</p>
<h3 id="debug-overlay-"><a class="header" href="#debug-overlay-">Debug Overlay ‚ùå</a></h3>
<p><strong>Location</strong>: <code>examples/debug_overlay</code><br />
<strong>Status</strong>: ‚ùå Has compilation issues (egui API)</p>
<p>Debug UI overlay for development.</p>
<p><strong>Known issues</strong>: egui API mismatches with current version.</p>
<h3 id="persona-loader-"><a class="header" href="#persona-loader-">Persona Loader ‚ö†Ô∏è</a></h3>
<p><strong>Location</strong>: <code>examples/persona_loader</code><br />
<strong>Status</strong>: ‚ö†Ô∏è Check compilation</p>
<p>Loading and managing AI personas from files.</p>
<pre><code class="language-bash">cargo run -p persona_loader --release
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>AI persona definition files</li>
<li>Dynamic persona loading</li>
<li>Personality trait configuration</li>
<li>Behavioral parameter tuning</li>
</ul>
<h2 id="known-compilation-issues"><a class="header" href="#known-compilation-issues">Known Compilation Issues</a></h2>
<p>Some examples have known issues due to API evolution:</p>
<h3 id="graphics-examples-"><a class="header" href="#graphics-examples-">Graphics Examples ‚ùå</a></h3>
<ul>
<li><strong>visual_3d</strong>: winit API mismatches</li>
<li><strong>ui_controls_demo</strong>: egui API compatibility issues</li>
<li><strong>debug_overlay</strong>: egui API changes</li>
</ul>
<h3 id="authoring-examples-"><a class="header" href="#authoring-examples-">Authoring Examples ‚ùå</a></h3>
<ul>
<li><strong>rhai_authoring</strong>: Depends on broken astraweave-author crate</li>
<li>Issues with rhai sync/send traits</li>
</ul>
<h3 id="complex-demos-"><a class="header" href="#complex-demos-">Complex Demos ‚ùå</a></h3>
<ul>
<li><strong>npc_town_demo</strong>: Multiple API mismatches</li>
<li><strong>weaving_playground</strong>: Dependency issues</li>
<li><strong>cutscene_render_demo</strong>: Graphics API issues</li>
</ul>
<h2 id="testing-examples"><a class="header" href="#testing-examples">Testing Examples</a></h2>
<p>To verify your installation is working:</p>
<h3 id="minimal-test-sequence"><a class="header" href="#minimal-test-sequence">Minimal Test Sequence</a></h3>
<pre><code class="language-bash"># 1. Build core components
cargo build -p astraweave-core -p astraweave-ai -p hello_companion

# 2. Run the basic example
cargo run -p hello_companion --release

# 3. Run unit tests
cargo test -p astraweave-input
</code></pre>
<h3 id="debugging-build-issues"><a class="header" href="#debugging-build-issues">Debugging Build Issues</a></h3>
<p>If examples fail to compile:</p>
<ol>
<li><strong>Check Rust version</strong>: <code>rustc --version</code> should match <code>rust-toolchain.toml</code></li>
<li><strong>Update dependencies</strong>: <code>cargo update</code></li>
<li><strong>Clean build</strong>: <code>cargo clean &amp;&amp; cargo build</code></li>
<li><strong>Check system dependencies</strong>: Ensure graphics and audio libraries are installed</li>
</ol>
<h3 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting Issues</a></h3>
<p>If you find compilation issues with examples marked as working:</p>
<ol>
<li>Check your platform and Rust version</li>
<li>Ensure all system dependencies are installed</li>
<li>Try a clean build</li>
<li>Report the issue with full error output</li>
</ol>
<h2 id="building-your-own-examples"><a class="header" href="#building-your-own-examples">Building Your Own Examples</a></h2>
<p>When creating new examples:</p>
<h3 id="minimal-example-structure"><a class="header" href="#minimal-example-structure">Minimal Example Structure</a></h3>
<pre><pre class="playground"><code class="language-rust">// examples/my_example/src/main.rs
use astraweave_core::*;
use astraweave_ai::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize the engine
    let mut world = World::new();
    
    // Add your systems
    world.add_system(my_custom_system);
    
    // Run the simulation
    world.run()?;
    
    Ok(())
}</code></pre></pre>
<h3 id="cargotoml-template"><a class="header" href="#cargotoml-template">Cargo.toml Template</a></h3>
<pre><code class="language-toml">[package]
name = "my_example"
version.workspace = true
edition.workspace = true

[dependencies]
astraweave-core = { path = "../../astraweave-core" }
astraweave-ai = { path = "../../astraweave-ai" }
anyhow.workspace = true
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><strong>Start Simple</strong>: Begin with <a href="examples/./hello-companion.html">Hello Companion</a></li>
<li><strong>Learn Architecture</strong>: Read <a href="examples/../architecture/ai-native.html">AI-Native Design</a></li>
<li><strong>Build Something</strong>: Follow <a href="examples/../game-dev/first-game.html">Building Your First Game</a></li>
<li><strong>Contribute</strong>: Help fix broken examples in <a href="examples/../dev/contributing.html">Contributing Guide</a></li>
</ul>
<hr />
<p><em>The working examples are your best introduction to AstraWeave's capabilities. Start with hello_companion and work your way up to more complex scenarios.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-companion-walkthrough"><a class="header" href="#hello-companion-walkthrough">Hello Companion Walkthrough</a></h1>
<p>The <code>hello_companion</code> example is the perfect introduction to AstraWeave's AI-native architecture. This walkthrough explains every step of what happens when you run this example and why it's designed this way.</p>
<h2 id="running-the-example"><a class="header" href="#running-the-example">Running the Example</a></h2>
<pre><code class="language-bash">cargo run -p hello_companion --release
</code></pre>
<h2 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h2>
<pre><code>[INFO] Initializing AstraWeave Engine...
[INFO] Creating world with ECS...
[INFO] Spawning AI companion entity
[INFO] Starting simulation loop at 60Hz
[INFO] Tick 1: Capturing perception snapshot
[INFO] AI perception: 1 entities visible, 0 audio events
[INFO] Sending perception to AI planning layer
[INFO] AI generated plan: MoveTo { target: Vec3(10.0, 0.0, 5.0), urgency: 0.7 }
[INFO] Validating movement tool usage...
[ERROR] Tool validation failed: LosBlocked - No clear line of sight to target
thread 'main' panicked at examples/hello_companion/src/main.rs:42:5:
called `Result::unwrap()` on an `Err` value: ToolValidationError(LosBlocked)
</code></pre>
<p><strong>This panic is intentional!</strong> It demonstrates AstraWeave's core principle: AI agents cannot perform actions that violate the game world's constraints.</p>
<h2 id="code-walkthrough"><a class="header" href="#code-walkthrough">Code Walkthrough</a></h2>
<p>Let's examine the source code to understand each step:</p>
<h3 id="1-engine-initialization"><a class="header" href="#1-engine-initialization">1. Engine Initialization</a></h3>
<pre><pre class="playground"><code class="language-rust">// examples/hello_companion/src/main.rs
use astraweave_core::*;
use astraweave_ai::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize logging
    env_logger::init();
    
    // Create the ECS world
    let mut world = World::new();
    
    // Configure the engine systems
    world.add_plugin(CorePlugin)
         .add_plugin(AIPlugin)
         .add_plugin(PhysicsPlugin);</code></pre></pre>
<p><strong>What's happening:</strong></p>
<ul>
<li>Sets up the Entity-Component-System (ECS) world</li>
<li>Registers core systems for AI, physics, and simulation</li>
<li>Configures 60Hz fixed-tick simulation</li>
</ul>
<h3 id="2-spawning-the-ai-companion"><a class="header" href="#2-spawning-the-ai-companion">2. Spawning the AI Companion</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Spawn an AI companion entity
    let companion = world.spawn()
        .insert(Position(Vec3::new(0.0, 0.0, 0.0)))
        .insert(AIAgent {
            perception_range: 10.0,
            planning_interval: Duration::from_millis(500),
            ai_model: AIModel::Local("companion-7b".to_string()),
        })
        .insert(MovementCapability {
            max_speed: 5.0,
            acceleration: 2.0,
        })
        .id();
    
    info!("Spawned AI companion with ID: {:?}", companion);
<span class="boring">}</span></code></pre></pre>
<p><strong>What's happening:</strong></p>
<ul>
<li>Creates a new entity in the ECS world</li>
<li>Adds position component (where the companion is)</li>
<li>Adds AI agent component (makes it intelligent)</li>
<li>Adds movement capability (what it can do)</li>
</ul>
<h3 id="3-the-simulation-loop"><a class="header" href="#3-the-simulation-loop">3. The Simulation Loop</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Run simulation for a few ticks
    for tick in 0..5 {
        info!("Starting tick {}", tick);
        
        // This is where the AI magic happens
        world.step(Duration::from_nanos(16_666_667)); // 1/60 second
        
        // Small delay so we can see the output
        std::thread::sleep(Duration::from_millis(100));
    }
<span class="boring">}</span></code></pre></pre>
<p><strong>What's happening:</strong></p>
<ul>
<li>Runs exactly 5 simulation ticks</li>
<li>Each tick advances the world by exactly 1/60th of a second</li>
<li>The deterministic timing ensures consistent behavior</li>
</ul>
<h3 id="4-the-ai-pipeline-inside-worldstep"><a class="header" href="#4-the-ai-pipeline-inside-worldstep">4. The AI Pipeline (Inside world.step())</a></h3>
<p>During each <code>world.step()</code> call, several systems run in sequence:</p>
<h4 id="a-perception-system"><a class="header" href="#a-perception-system">A. Perception System</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ai_perception_system(
    mut query: Query&lt;(&amp;Position, &amp;AIAgent, &amp;mut PerceptionState)&gt;,
    world_query: Query&lt;&amp;Position&gt;,
) {
    for (pos, agent, mut perception) in query.iter_mut() {
        // Gather what the AI can see
        let mut visible_entities = Vec::new();
        
        for other_pos in world_query.iter() {
            let distance = pos.0.distance(other_pos.0);
            if distance &lt;= agent.perception_range {
                visible_entities.push(EntityData {
                    position: other_pos.0,
                    distance,
                    entity_type: "unknown".to_string(),
                });
            }
        }
        
        // Create perception snapshot
        perception.last_snapshot = Some(PerceptionSnapshot {
            timestamp: world.current_tick(),
            agent_id: entity,
            visible_entities,
            audio_events: vec![], // None in this simple example
            world_state: WorldState::default(),
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="b-ai-planning-system"><a class="header" href="#b-ai-planning-system">B. AI Planning System</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ai_planning_system(
    mut query: Query&lt;(&amp;AIAgent, &amp;PerceptionState, &amp;mut PlanningState)&gt;,
    ai_service: Res&lt;AIService&gt;,
) {
    for (agent, perception, mut planning) in query.iter_mut() {
        if let Some(snapshot) = &amp;perception.last_snapshot {
            // Send to AI model for planning
            let plan_request = PlanningRequest {
                perception: snapshot.clone(),
                agent_profile: agent.clone(),
                available_tools: vec!["MovementTool", "InteractionTool"],
            };
            
            // This is where the LLM generates a plan
            let plan = ai_service.generate_plan(plan_request)?;
            
            info!("AI generated plan: {:?}", plan.intent);
            planning.current_plan = Some(plan);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="c-tool-validation-system"><a class="header" href="#c-tool-validation-system">C. Tool Validation System</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tool_validation_system(
    mut query: Query&lt;(&amp;PlanningState, &amp;mut ActionState)&gt;,
    tool_registry: Res&lt;ToolRegistry&gt;,
    world: &amp;World,
) {
    for (planning, mut action) in query.iter_mut() {
        if let Some(plan) = &amp;planning.current_plan {
            for tool_usage in &amp;plan.tools {
                // This is where the validation happens
                let validation_result = tool_registry
                    .get_tool(&amp;tool_usage.tool_name)
                    .unwrap()
                    .validate(world, tool_usage);
                
                match validation_result {
                    ValidationResult::Valid =&gt; {
                        info!("Tool validation passed: {}", tool_usage.tool_name);
                        action.pending_actions.push(tool_usage.clone());
                    }
                    ValidationResult::Blocked(reason) =&gt; {
                        error!("Tool validation failed: {:?}", reason);
                        // This causes the panic in hello_companion
                        return Err(ToolValidationError::from(reason));
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="why-does-it-panic"><a class="header" href="#why-does-it-panic">Why Does It Panic?</a></h2>
<p>The panic occurs because the AI tries to move to a position but there's no clear line of sight. Here's what happens:</p>
<h3 id="1-ai-perception"><a class="header" href="#1-ai-perception">1. AI Perception</a></h3>
<ul>
<li>The companion perceives its current position (0, 0, 0)</li>
<li>It detects no obstacles in its perception range</li>
</ul>
<h3 id="2-ai-planning"><a class="header" href="#2-ai-planning">2. AI Planning</a></h3>
<ul>
<li>The AI decides it wants to move to position (10, 0, 5)</li>
<li>This seems reasonable based on its limited perception</li>
</ul>
<h3 id="3-tool-validation-1"><a class="header" href="#3-tool-validation-1">3. Tool Validation</a></h3>
<ul>
<li>The MovementTool.validate() method checks line of sight</li>
<li>There's an invisible obstacle blocking the path</li>
<li>Validation fails with <code>LosBlocked</code> error</li>
</ul>
<h3 id="4-engine-authority"><a class="header" href="#4-engine-authority">4. Engine Authority</a></h3>
<ul>
<li>The engine refuses to execute the invalid action</li>
<li>This maintains world integrity and prevents AI cheating</li>
</ul>
<h2 id="key-learning-points"><a class="header" href="#key-learning-points">Key Learning Points</a></h2>
<h3 id="1-ai-cannot-cheat"><a class="header" href="#1-ai-cannot-cheat">1. AI Cannot Cheat</a></h3>
<p>The AI doesn't have perfect information about the world. It can only act based on what it perceives, and all actions must be validated by the engine.</p>
<h3 id="2-deterministic-behavior"><a class="header" href="#2-deterministic-behavior">2. Deterministic Behavior</a></h3>
<p>Run the example multiple times - you'll get the same result every time. This determinism is crucial for:</p>
<ul>
<li>Reliable testing</li>
<li>Networking (same simulation on all clients)</li>
<li>Debugging AI behavior</li>
</ul>
<h3 id="3-tool-based-architecture"><a class="header" href="#3-tool-based-architecture">3. Tool-Based Architecture</a></h3>
<p>The AI doesn't directly move entities or change the world. It can only request actions through validated tools:</p>
<ul>
<li>MovementTool (for movement)</li>
<li>InteractionTool (for object interaction)</li>
<li>CombatTool (for attacks)</li>
<li>CommunicationTool (for dialogue)</li>
</ul>
<h3 id="4-perception-vs-reality"><a class="header" href="#4-perception-vs-reality">4. Perception vs Reality</a></h3>
<p>The AI's perception is limited and may not match reality. This creates interesting emergent behavior as AI agents must:</p>
<ul>
<li>Explore to gather information</li>
<li>Make decisions with incomplete data</li>
<li>Adapt when actions fail</li>
</ul>
<h2 id="modifying-the-example"><a class="header" href="#modifying-the-example">Modifying the Example</a></h2>
<h3 id="make-it-not-panic"><a class="header" href="#make-it-not-panic">Make It Not Panic</a></h3>
<p>To see successful AI behavior, modify the world setup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove the obstacle that blocks line of sight
world.remove_obstacle(Vec3::new(5.0, 0.0, 2.5));

// Or give the AI perfect perception
ai_agent.perception_range = f32::INFINITY;
<span class="boring">}</span></code></pre></pre>
<h3 id="add-more-interesting-behavior"><a class="header" href="#add-more-interesting-behavior">Add More Interesting Behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add a target for the AI to find
world.spawn()
    .insert(Position(Vec3::new(15.0, 0.0, 0.0)))
    .insert(InteractableItem {
        item_type: "treasure_chest".to_string(),
        value: 100,
    });

// The AI will now try to navigate to and interact with the chest
<span class="boring">}</span></code></pre></pre>
<h3 id="enable-logging-for-more-detail"><a class="header" href="#enable-logging-for-more-detail">Enable Logging for More Detail</a></h3>
<pre><code class="language-bash">RUST_LOG=debug cargo run -p hello_companion --release
</code></pre>
<p>This shows detailed information about:</p>
<ul>
<li>ECS system execution order</li>
<li>AI model input/output</li>
<li>Tool validation steps</li>
<li>World state changes</li>
</ul>
<h2 id="architectural-insights"><a class="header" href="#architectural-insights">Architectural Insights</a></h2>
<h3 id="fixed-tick-simulation-1"><a class="header" href="#fixed-tick-simulation-1">Fixed-Tick Simulation</a></h3>
<p>The 60Hz fixed timestep ensures:</p>
<ul>
<li>Physics determinism</li>
<li>Consistent AI decision making</li>
<li>Reliable networking</li>
<li>Predictable performance</li>
</ul>
<h3 id="ecs-benefits"><a class="header" href="#ecs-benefits">ECS Benefits</a></h3>
<p>The Entity-Component-System architecture provides:</p>
<ul>
<li>Cache-friendly performance</li>
<li>Clear separation of concerns</li>
<li>Easy parallel system execution</li>
<li>Modular, testable code</li>
</ul>
<h3 id="ai-validation-pipeline"><a class="header" href="#ai-validation-pipeline">AI Validation Pipeline</a></h3>
<p>The perception ‚Üí planning ‚Üí validation ‚Üí execution pipeline ensures:</p>
<ul>
<li>No AI cheating</li>
<li>Consistent game rules</li>
<li>Emergent behavior from constraints</li>
<li>Easy debugging and testing</li>
</ul>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>After understanding hello_companion:</p>
<ol>
<li><strong>Explore More Examples</strong>: Try <a href="examples/./adaptive-boss.html">Adaptive Boss</a> for complex AI</li>
<li><strong>Learn Architecture</strong>: Read <a href="examples/../architecture/ai-native.html">AI-Native Design</a></li>
<li><strong>Build Your Own</strong>: Follow <a href="examples/../game-dev/first-game.html">Building Your First Game</a></li>
<li><strong>Dive Deeper</strong>: Study <a href="examples/../core-systems/ai/index.html">Core AI Systems</a></li>
</ol>
<h2 id="common-questions"><a class="header" href="#common-questions">Common Questions</a></h2>
<h3 id="q-why-does-it-panic-instead-of-just-logging-the-error"><a class="header" href="#q-why-does-it-panic-instead-of-just-logging-the-error">Q: Why does it panic instead of just logging the error?</a></h3>
<p><strong>A</strong>: The panic demonstrates that validation failures are serious. In a real game, you'd handle this gracefully, but the example uses panic to make the validation concept crystal clear.</p>
<h3 id="q-can-i-make-the-ai-smarter-to-avoid-this-error"><a class="header" href="#q-can-i-make-the-ai-smarter-to-avoid-this-error">Q: Can I make the AI smarter to avoid this error?</a></h3>
<p><strong>A</strong>: Yes! You can:</p>
<ul>
<li>Improve the AI's perception system</li>
<li>Give it better pathfinding tools</li>
<li>Add obstacle detection to its planning</li>
<li>Implement learning from failed actions</li>
</ul>
<h3 id="q-is-this-really-how-a-game-ai-should-work"><a class="header" href="#q-is-this-really-how-a-game-ai-should-work">Q: Is this really how a game AI should work?</a></h3>
<p><strong>A</strong>: For AI-native games, yes! This approach:</p>
<ul>
<li>Prevents AI cheating</li>
<li>Creates emergent behavior</li>
<li>Works in multiplayer</li>
<li>Enables complex AI interactions</li>
</ul>
<p>The "failed action = learning opportunity" approach leads to much more interesting AI behavior than scripted sequences.</p>
<hr />
<p><em>The hello_companion example may be simple, but it demonstrates the fundamental principles that enable AstraWeave's AI-native gameplay. Every complex AI behavior in the engine builds on these same validation patterns.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adaptive-boss"><a class="header" href="#adaptive-boss">Adaptive Boss</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-demo"><a class="header" href="#physics-demo">Physics Demo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navmesh-demo"><a class="header" href="#navmesh-demo">Navmesh Demo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-spatial"><a class="header" href="#audio-spatial">Audio Spatial</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-examples"><a class="header" href="#troubleshooting-examples">Troubleshooting Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="veilweaver-overview"><a class="header" href="#veilweaver-overview">Veilweaver Overview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-mechanics"><a class="header" href="#game-mechanics">Game Mechanics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai-integration"><a class="header" href="#ai-integration">AI Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world-design"><a class="header" href="#world-design">World Design</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-guide"><a class="header" href="#contributing-guide">Contributing Guide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-style"><a class="header" href="#code-style">Code Style</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-new-features"><a class="header" href="#adding-new-features">Adding New Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate-documentation"><a class="header" href="#crate-documentation">Crate Documentation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tools"><a class="header" href="#command-line-tools">Command Line Tools</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h1>
<p>This guide helps you solve common issues when working with AstraWeave. Issues are organized by category with specific solutions.</p>
<h2 id="build-issues"><a class="header" href="#build-issues">Build Issues</a></h2>
<h3 id="rust-toolchain-problems"><a class="header" href="#rust-toolchain-problems">Rust Toolchain Problems</a></h3>
<h4 id="error-rustc-version-mismatch"><a class="header" href="#error-rustc-version-mismatch">Error: "rustc version mismatch"</a></h4>
<pre><code>error: rustc version doesn't match the expected version
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Remove existing toolchain and reinstall
rustup toolchain uninstall stable
rustup toolchain install 1.89.0
rustup default 1.89.0

# Verify version
rustc --version  # Should show 1.89.0
</code></pre>
<h4 id="error-rust-toolchaintoml-not-respected"><a class="header" href="#error-rust-toolchaintoml-not-respected">Error: "rust-toolchain.toml not respected"</a></h4>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Force toolchain installation
rustup toolchain install 1.89.0
rustup override set 1.89.0

# Clean and rebuild
cargo clean
cargo build -p astraweave-core
</code></pre>
<h3 id="dependency-issues"><a class="header" href="#dependency-issues">Dependency Issues</a></h3>
<h4 id="error-linker-cc-not-found"><a class="header" href="#error-linker-cc-not-found">Error: "linker <code>cc</code> not found"</a></h4>
<p><strong>Linux Solution:</strong></p>
<pre><code class="language-bash">sudo apt-get install build-essential
</code></pre>
<p><strong>macOS Solution:</strong></p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<p><strong>Windows Solution:</strong>
Install Visual Studio with C++ build tools.</p>
<h4 id="error-failed-to-find-required-package"><a class="header" href="#error-failed-to-find-required-package">Error: "failed to find required package"</a></h4>
<pre><code>error: could not find `wgpu` in the registry
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Update Cargo registry
cargo update

# If still failing, clear cache
rm -rf ~/.cargo/registry
cargo update
</code></pre>
<h3 id="graphics-dependencies"><a class="header" href="#graphics-dependencies">Graphics Dependencies</a></h3>
<h4 id="error-vulkan-not-found"><a class="header" href="#error-vulkan-not-found">Error: "Vulkan not found"</a></h4>
<p><strong>Linux Solution:</strong></p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get install mesa-vulkan-drivers vulkan-tools

# Arch Linux  
sudo pacman -S vulkan-devel mesa

# Fedora
sudo dnf install vulkan-devel mesa-dri-drivers

# Verify Vulkan
vulkaninfo | head -20
</code></pre>
<p><strong>Windows Solution:</strong>
Update your graphics drivers from manufacturer website:</p>
<ul>
<li>NVIDIA: Download latest drivers</li>
<li>AMD: Download Adrenalin drivers</li>
<li>Intel: Download latest graphics drivers</li>
</ul>
<p><strong>macOS Solution:</strong>
Vulkan support requires MoltenVK:</p>
<pre><code class="language-bash">brew install molten-vk
</code></pre>
<h4 id="error-wgpu-adapter-not-found"><a class="header" href="#error-wgpu-adapter-not-found">Error: "wgpu adapter not found"</a></h4>
<pre><code>thread 'main' panicked at 'No suitable graphics adapter found'
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Check GPU compatibility:</strong></p>
<pre><code class="language-bash"># Linux: Check Vulkan support
vulkaninfo

# Should show at least one device
</code></pre>
</li>
<li>
<p><strong>Force software rendering:</strong></p>
<pre><code class="language-bash">export WGPU_BACKEND=gl
cargo run -p hello_companion
</code></pre>
</li>
<li>
<p><strong>Update graphics drivers</strong></p>
</li>
</ol>
<h3 id="audio-dependencies"><a class="header" href="#audio-dependencies">Audio Dependencies</a></h3>
<h4 id="error-alsa-lib-errors-linux"><a class="header" href="#error-alsa-lib-errors-linux">Error: "ALSA lib errors" (Linux)</a></h4>
<pre><code>ALSA lib pcm_dmix.c:1089:(snd_pcm_dmix_open) unable to open slave
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Install audio libraries
sudo apt-get install libasound2-dev libpulse-dev

# Check audio devices
aplay -l

# If no devices, check PulseAudio
pulseaudio --check
</code></pre>
<h4 id="error-no-audio-output-device-found"><a class="header" href="#error-no-audio-output-device-found">Error: "No audio output device found"</a></h4>
<p><strong>Linux Solution:</strong></p>
<pre><code class="language-bash"># Restart audio services
systemctl --user restart pulseaudio
</code></pre>
<p><strong>Windows Solution:</strong>
Check that Windows Audio service is running in Services.</p>
<p><strong>macOS Solution:</strong>
Usually works out of the box. Check System Preferences &gt; Sound.</p>
<h3 id="example-compilation-issues"><a class="header" href="#example-compilation-issues">Example Compilation Issues</a></h3>
<h4 id="error-examples-fail-to-compile"><a class="header" href="#error-examples-fail-to-compile">Error: "examples fail to compile"</a></h4>
<p>Many examples have known compilation issues. Use only the working examples:</p>
<p><strong>Working Examples:</strong></p>
<pre><code class="language-bash">cargo build -p hello_companion      # ‚úÖ Works (expected panic)
cargo build -p ipc_loopback        # ‚úÖ Should work  
cargo test -p astraweave-input      # ‚úÖ Tests pass
</code></pre>
<p><strong>Known Broken Examples:</strong></p>
<pre><code class="language-bash"># ‚ùå These have compilation issues:
# cargo build -p debug_toolkit_demo  # egui/winit/renderer API mismatches
# cargo build -p aw_editor           # eframe/glutin sync/send trait issues  
# cargo build -p aw_debug            # eframe API mismatches
# cargo build -p visual_3d           # clippy deny-level errors
# cargo build -p navmesh_demo        # clippy deny-level errors (approx_constant)
# cargo build -p physics_demo3d      # clippy deny-level errors (approx_constant)
</code></pre>
<p><strong>Workaround:</strong>
Focus on the working core components and use the provided aliases:</p>
<pre><code class="language-bash">cargo build-core                    # Build core components only
cargo check-all                     # Check workspace (excluding problematic crates)
cargo clippy-all                    # Run clippy on working crates
</code></pre>
<h2 id="runtime-issues-1"><a class="header" href="#runtime-issues-1">Runtime Issues</a></h2>
<h3 id="graphics-issues"><a class="header" href="#graphics-issues">Graphics Issues</a></h3>
<h4 id="error-validation-error-in-wgpu"><a class="header" href="#error-validation-error-in-wgpu">Error: "Validation error in wgpu"</a></h4>
<pre><code>wgpu validation error: Buffer usage VERTEX | COPY_DST is not valid
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li><strong>Update graphics drivers</strong></li>
<li><strong>Use older wgpu backend:</strong>
<pre><code class="language-bash">export WGPU_BACKEND=vulkan  # or gl, metal, dx12
</code></pre>
</li>
<li><strong>Reduce graphics settings in your code</strong></li>
</ol>
<h4 id="error-surface-creation-failed"><a class="header" href="#error-surface-creation-failed">Error: "Surface creation failed"</a></h4>
<pre><code>Error creating surface: SurfaceError(OutOfMemory)
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li><strong>Reduce window size:</strong>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your window configuration
.with_inner_size(winit::dpi::LogicalSize::new(800, 600))
<span class="boring">}</span></code></pre></pre>
</li>
<li><strong>Lower graphics quality settings</strong></li>
<li><strong>Check available VRAM:</strong>
<pre><code class="language-bash"># Linux
nvidia-smi  # for NVIDIA
radeontop   # for AMD
</code></pre>
</li>
</ol>
<h3 id="ai-model-issues"><a class="header" href="#ai-model-issues">AI Model Issues</a></h3>
<h4 id="error-ai-model-not-found"><a class="header" href="#error-ai-model-not-found">Error: "AI model not found"</a></h4>
<pre><code>Error: Could not load AI model 'companion-7b'
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Use mock AI for testing:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your configuration
ai_agent.ai_model = AIModel::Mock;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Download required models:</strong></p>
<pre><code class="language-bash"># Models not included in repository
# Use mock or implement your own model loader
</code></pre>
</li>
<li>
<p><strong>Configure model path:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ai_agent.ai_model = AIModel::Local("path/to/your/model".to_string());
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="performance-issues-1"><a class="header" href="#performance-issues-1">Performance Issues</a></h3>
<h4 id="issue-low-fps--stuttering"><a class="header" href="#issue-low-fps--stuttering">Issue: "Low FPS / Stuttering"</a></h4>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash"># Always use release builds for performance testing
cargo run -p hello_companion --release

# Check if running in debug mode
cargo run -p hello_companion  # This is debug mode - will be slow
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Always use release builds:</strong></p>
<pre><code class="language-bash">cargo build --release
cargo run --release -p your_example
</code></pre>
</li>
<li>
<p><strong>Check system resources:</strong></p>
<pre><code class="language-bash"># Linux
htop

# Monitor GPU usage
nvidia-smi  # NVIDIA
radeontop   # AMD
</code></pre>
</li>
<li>
<p><strong>Reduce AI complexity:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lower AI planning frequency
ai_agent.planning_interval = Duration::from_millis(1000); // Instead of 500

// Reduce perception range
ai_agent.perception_range = 5.0; // Instead of 10.0
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h4 id="issue-high-memory-usage"><a class="header" href="#issue-high-memory-usage">Issue: "High memory usage"</a></h4>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash"># Check memory usage
cargo run --release -p hello_companion &amp;
ps aux | grep hello_companion
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Limit AI memory:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ai_memory.max_episodic_memories = 100;
ai_memory.max_working_memory = 10;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use memory profiling:</strong></p>
<pre><code class="language-bash"># Install valgrind (Linux)
sudo apt-get install valgrind
valgrind --tool=massif cargo run --release -p hello_companion
</code></pre>
</li>
</ol>
<h3 id="network-issues"><a class="header" href="#network-issues">Network Issues</a></h3>
<h4 id="error-connection-refused-multiplayer-examples"><a class="header" href="#error-connection-refused-multiplayer-examples">Error: "Connection refused" (multiplayer examples)</a></h4>
<pre><code>Error: Connection refused (os error 111)
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Check if server is running:</strong></p>
<pre><code class="language-bash"># Terminal 1 - Start server first
cargo run -p coop_server --release

# Terminal 2 - Then client
cargo run -p coop_client --release
</code></pre>
</li>
<li>
<p><strong>Check firewall settings:</strong></p>
<pre><code class="language-bash"># Linux: Check if port is open
sudo ufw status

# Allow port if needed
sudo ufw allow 8080
</code></pre>
</li>
<li>
<p><strong>Use localhost:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make sure client connects to localhost
let server_addr = "127.0.0.1:8080";
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="development-issues"><a class="header" href="#development-issues">Development Issues</a></h2>
<h3 id="ide-problems"><a class="header" href="#ide-problems">IDE Problems</a></h3>
<h4 id="issue-rust-analyzer-not-working"><a class="header" href="#issue-rust-analyzer-not-working">Issue: "rust-analyzer not working"</a></h4>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Restart rust-analyzer
# In VS Code: Ctrl+Shift+P &gt; "Rust Analyzer: Restart Server"

# Or reinstall
rustup component add rust-analyzer
</code></pre>
<h4 id="issue-slow-code-completion"><a class="header" href="#issue-slow-code-completion">Issue: "Slow code completion"</a></h4>
<p><strong>Solutions:</strong></p>
<ol>
<li><strong>Exclude target directory from indexing</strong></li>
<li><strong>Reduce project scope:</strong>
<pre><code class="language-json">// In VS Code settings.json
{
  "rust-analyzer.cargo.allFeatures": false,
  "rust-analyzer.checkOnSave.allFeatures": false
}
</code></pre>
</li>
</ol>
<h3 id="testing-issues"><a class="header" href="#testing-issues">Testing Issues</a></h3>
<h4 id="error-tests-hanging"><a class="header" href="#error-tests-hanging">Error: "Tests hanging"</a></h4>
<pre><code class="language-bash">cargo test -p astraweave-input
# Hangs indefinitely
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>
<p><strong>Run with timeout:</strong></p>
<pre><code class="language-bash">timeout 30s cargo test -p astraweave-input
</code></pre>
</li>
<li>
<p><strong>Run single test:</strong></p>
<pre><code class="language-bash">cargo test -p astraweave-input test_input_system
</code></pre>
</li>
<li>
<p><strong>Use single-threaded execution:</strong></p>
<pre><code class="language-bash">cargo test -p astraweave-input -- --test-threads=1
</code></pre>
</li>
</ol>
<h4 id="error-test-failures-due-to-timing"><a class="header" href="#error-test-failures-due-to-timing">Error: "Test failures due to timing"</a></h4>
<pre><code>thread 'ai_planning_test' panicked at 'assertion failed: plan.is_some()'
</code></pre>
<p><strong>Solution:</strong>
Tests involving AI may have timing dependencies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add delays in tests
#[test]
fn ai_planning_test() {
    let mut world = create_test_world();
    world.step(); // Let one frame pass
    
    std::thread::sleep(Duration::from_millis(100)); // Give AI time to plan
    
    let plan = world.get_ai_plan();
    assert!(plan.is_some());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="platform-specific-issues-1"><a class="header" href="#platform-specific-issues-1">Platform-Specific Issues</a></h2>
<h3 id="linux-issues"><a class="header" href="#linux-issues">Linux Issues</a></h3>
<h4 id="issue-wayland-compatibility"><a class="header" href="#issue-wayland-compatibility">Issue: "Wayland compatibility"</a></h4>
<p>Some features may not work correctly on Wayland:</p>
<pre><code class="language-bash"># Force X11 if needed
export WAYLAND_DISPLAY=""
export DISPLAY=:0

# Or force Wayland if X11 is causing issues
export DISPLAY=""
</code></pre>
<h4 id="issue-audio-permission-denied"><a class="header" href="#issue-audio-permission-denied">Issue: "Audio permission denied"</a></h4>
<pre><code class="language-bash"># Add user to audio group
sudo usermod -a -G audio $USER

# Restart session or reboot
</code></pre>
<h3 id="macos-issues"><a class="header" href="#macos-issues">macOS Issues</a></h3>
<h4 id="issue-code-signing-errors"><a class="header" href="#issue-code-signing-errors">Issue: "Code signing errors"</a></h4>
<pre><code>error: codesign failed with exit code 1
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># For development, disable code signing
export MACOSX_DEPLOYMENT_TARGET=11.0

# Or sign manually
codesign --force --deep --sign - target/release/hello_companion
</code></pre>
<h4 id="issue-metal-validation-errors"><a class="header" href="#issue-metal-validation-errors">Issue: "Metal validation errors"</a></h4>
<p>Use software rendering if Metal causes issues:</p>
<pre><code class="language-bash">export WGPU_BACKEND=gl
cargo run -p hello_companion --release
</code></pre>
<h3 id="windows-issues"><a class="header" href="#windows-issues">Windows Issues</a></h3>
<h4 id="issue-msvc-runtime-missing"><a class="header" href="#issue-msvc-runtime-missing">Issue: "MSVC runtime missing"</a></h4>
<p>Install Microsoft Visual C++ Redistributable:</p>
<ul>
<li>Download from Microsoft's website</li>
<li>Or install Visual Studio with C++ tools</li>
</ul>
<h4 id="issue-antivirus-blocking-execution"><a class="header" href="#issue-antivirus-blocking-execution">Issue: "Antivirus blocking execution"</a></h4>
<p>Add exclusions for:</p>
<ul>
<li>Project directory</li>
<li><code>%USERPROFILE%\.cargo</code></li>
<li><code>target\</code> directory</li>
</ul>
<h4 id="issue-path-too-long-errors"><a class="header" href="#issue-path-too-long-errors">Issue: "Path too long errors"</a></h4>
<pre><code class="language-bash"># Enable long paths in Windows
# Run as Administrator in PowerShell:
New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem" -Name "LongPathsEnabled" -Value 1 -PropertyType DWORD -Force
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<h3 id="before-asking-for-help"><a class="header" href="#before-asking-for-help">Before Asking for Help</a></h3>
<ol>
<li><strong>Check this troubleshooting guide</strong></li>
<li><strong>Verify your setup:</strong>
<pre><code class="language-bash">rustc --version  # Should be 1.89.0
cargo --version
</code></pre>
</li>
<li><strong>Try with minimal example:</strong>
<pre><code class="language-bash">cargo run -p hello_companion --release
</code></pre>
</li>
<li><strong>Check system dependencies</strong></li>
</ol>
<h3 id="information-to-include"><a class="header" href="#information-to-include">Information to Include</a></h3>
<p>When reporting issues, include:</p>
<ol>
<li>
<p><strong>System information:</strong></p>
<pre><code class="language-bash"># Linux
uname -a
lsb_release -a

# macOS
sw_vers

# Windows
systeminfo
</code></pre>
</li>
<li>
<p><strong>Rust version:</strong></p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
</li>
<li>
<p><strong>Graphics information:</strong></p>
<pre><code class="language-bash"># Linux
lspci | grep VGA
vulkaninfo | head -20

# Windows
dxdiag

# macOS
system_profiler SPDisplaysDataType
</code></pre>
</li>
<li>
<p><strong>Full error output:</strong></p>
<pre><code class="language-bash"># Include full error with backtrace
RUST_BACKTRACE=full cargo run -p hello_companion 2&gt;&amp;1 | tee error.log
</code></pre>
</li>
<li>
<p><strong>Steps to reproduce</strong></p>
</li>
</ol>
<h3 id="community-resources"><a class="header" href="#community-resources">Community Resources</a></h3>
<ul>
<li><strong>GitHub Issues</strong>: For bug reports and feature requests</li>
<li><strong>Discussions</strong>: For questions and general help</li>
<li><strong>Matrix/Discord</strong>: For real-time community support (if available)</li>
</ul>
<h3 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h3>
<h4 id="current-development-state"><a class="header" href="#current-development-state">Current Development State</a></h4>
<p>AstraWeave is under active development. Known limitations:</p>
<ol>
<li><strong>Many examples don't compile</strong> due to API evolution</li>
<li><strong>Limited AI model integration</strong> - mostly uses mock AI</li>
<li><strong>Graphics API compatibility</strong> - some newer GPU features not supported</li>
<li><strong>Documentation gaps</strong> - some advanced features lack documentation</li>
</ol>
<h4 id="workarounds"><a class="header" href="#workarounds">Workarounds</a></h4>
<ol>
<li><strong>Focus on working examples</strong> (hello_companion, core components)</li>
<li><strong>Use mock AI</strong> for learning the architecture</li>
<li><strong>Stick to stable APIs</strong> in core crates</li>
<li><strong>Contribute fixes</strong> for broken examples</li>
</ol>
<hr />
<p><em>If you're still having issues after trying these solutions, please create an issue on GitHub with the requested information. The community is here to help!</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community"><a class="header" href="#community">Community</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
