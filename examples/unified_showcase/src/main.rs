//! Modified unified_showcase main file with improved controls, teleport fix, procedural ground, and interaction.
// (Generated by ChatGPT)
mod texture_synth;

use anyhow::Result;
use glam::{Mat4, Vec2, Vec3};
use image::GenericImageView;
use rapier3d::prelude as r3;
use rapier3d::prelude::nalgebra; // Add nalgebra import
use serde::Deserialize;
use std::{borrow::Cow, fs, path::Path, time::Instant};
use wgpu::util::DeviceExt;
use winit::{
    event::{DeviceEvent, ElementState, Event, KeyEvent, MouseScrollDelta, WindowEvent},
    event_loop::EventLoop,
    keyboard::{KeyCode, PhysicalKey},
    window::{CursorGrabMode, WindowBuilder},
};

// Import the proper camera system from astraweave-render
use astraweave_render::camera::{Camera as RenderCamera, CameraController};

// ------------------------------- Renderer types -------------------------------

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct GpuCamera {
    view_proj: [f32; 16],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct InstanceRaw {
    model: [f32; 16],
    color: [f32; 4],
}

struct RenderStuff {
    surface: wgpu::Surface<'static>,
    surface_cfg: wgpu::SurfaceConfiguration,
    device: wgpu::Device,
    queue: wgpu::Queue,
    depth_view: wgpu::TextureView,
    pipeline: wgpu::RenderPipeline,
    cube_vb: wgpu::Buffer,
    cube_ib: wgpu::Buffer,
    cube_index_count: u32,
    camera_ub: wgpu::Buffer,
    camera_bg: wgpu::BindGroup,
    instance_vb: wgpu::Buffer,
    instance_count: u32,
    msaa_samples: u32,
    // Texture resources
    ground_texture: Option<LoadedTexture>,
    texture_bind_group_layout: wgpu::BindGroupLayout,
    ground_bind_group: Option<wgpu::BindGroup>,
    ground_normal: Option<LoadedTexture>,
}

const DEPTH_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth24Plus;

// ------------------------------- Texture Pack System -------------------------------

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct TexturePack {
    name: String,
    description: String,
    ground: GroundConfig,
    structures: StructuresConfig,
    sky: SkyConfig,
    ambient: AmbientConfig,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct GroundConfig {
    texture: String,
    scale: f32,
    color_tint: [f32; 4],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct StructuresConfig {
    buildings: Vec<BuildingConfig>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct BuildingConfig {
    #[serde(rename = "type")]
    building_type: String,
    base_texture: String,
    roof_texture: String,
    probability: f32,
    size_range: [f32; 2],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct SkyConfig {
    horizon_color: [f32; 3],
    zenith_color: [f32; 3],
    sun_color: [f32; 3],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct AmbientConfig {
    light_color: [f32; 3],
    light_intensity: f32,
    fog_color: [f32; 3],
    fog_density: f32,
}

struct LoadedTexture {
    #[allow(dead_code)] // Texture handle kept for resource management
    texture: wgpu::Texture,
    view: wgpu::TextureView,
    sampler: wgpu::Sampler,
}

const CUBE_VERTICES: &[[f32; 3]] = &[
    // A simple unit cube centered at origin
    // front
    [-0.5, -0.5, 0.5],
    [0.5, -0.5, 0.5],
    [0.5, 0.5, 0.5],
    [-0.5, 0.5, 0.5],
    // back
    [-0.5, -0.5, -0.5],
    [-0.5, 0.5, -0.5],
    [0.5, 0.5, -0.5],
    [0.5, -0.5, -0.5],
];

const CUBE_INDICES: &[u16] = &[
    // front
    0, 1, 2, 0, 2, 3, // right
    1, 7, 6, 1, 6, 2, // back
    7, 4, 5, 7, 5, 6, // left
    4, 0, 3, 4, 3, 5, // top
    3, 2, 6, 3, 6, 5, // bottom
    4, 7, 1, 4, 1, 0,
];

// ------------------------------- Egui wiring -------------------------------

#[allow(dead_code)] // UI state fields may be used in future iterations
struct UiState {
    show_grid: bool,
    show_navmesh: bool,
    show_path: bool,
    physics_paused: bool,
    camera_speed: f32,
    resolution_scale: f32,
    fake_ao: bool,
    fake_reflections: bool,
    fps_text: String,
    info_text: String,
    current_texture_pack: String,
    available_texture_packs: Vec<String>,
}

impl Default for UiState {
    fn default() -> Self {
        Self {
            show_grid: true,
            show_navmesh: true,
            show_path: true,
            physics_paused: false,
            camera_speed: 8.0,
            resolution_scale: 1.0,
            fake_ao: true,
            fake_reflections: false,
            fps_text: String::new(),
            info_text: "AstraWeave Unified Showcase".to_string(),
            current_texture_pack: "grassland".to_string(),
            available_texture_packs: vec!["grassland".to_string(), "desert".to_string()],
        }
    }
}

// ------------------------------- Camera -------------------------------
// Use the proper camera system from astraweave-render

// ------------------------------- Character System -------------------------------

#[derive(Clone)]
struct Character {
    position: Vec3,
    velocity: Vec3,
    target_position: Vec3,
    character_type: CharacterType,
    animation_time: f32,
    patrol_points: Vec<Vec3>,
    current_patrol_index: usize,
}

#[derive(Clone)]
enum CharacterType {
    Villager,
    Guard,
    Merchant,
    Animal,
}

impl Character {
    fn new(pos: Vec3, char_type: CharacterType) -> Self {
        Self {
            position: pos,
            velocity: Vec3::ZERO,
            target_position: pos,
            character_type: char_type,
            animation_time: 0.0,
            patrol_points: Vec::new(),
            current_patrol_index: 0,
        }
    }

    fn update(&mut self, dt: f32) {
        self.animation_time += dt;

        // Simple AI behavior - move towards target
        let direction = (self.target_position - self.position).normalize_or_zero();
        let speed = match self.character_type {
            CharacterType::Villager => 1.5,
            CharacterType::Guard => 2.0,
            CharacterType::Merchant => 1.2,
            CharacterType::Animal => 2.5,
        };

        self.velocity = direction * speed;
        self.position += self.velocity * dt;

        // Check if reached target and update patrol
        if (self.position - self.target_position).length() < 1.0 && !self.patrol_points.is_empty() {
            self.current_patrol_index = (self.current_patrol_index + 1) % self.patrol_points.len();
            self.target_position = self.patrol_points[self.current_patrol_index];
        }
    }

    fn get_color(&self) -> [f32; 4] {
        match self.character_type {
            CharacterType::Villager => [0.8, 0.6, 0.4, 1.0], // Tan
            CharacterType::Guard => [0.3, 0.3, 0.8, 1.0],    // Blue
            CharacterType::Merchant => [0.6, 0.3, 0.8, 1.0], // Purple
            CharacterType::Animal => [0.9, 0.7, 0.5, 1.0],   // Light brown
        }
    }
}

#[derive(Default)]
struct InputState {
    scroll_delta: f32,
}

// ------------------------------- Physics -------------------------------

struct Physics {
    pipeline: r3::PhysicsPipeline,
    gravity: r3::Vector<f32>,
    islands: r3::IslandManager,
    broad: r3::DefaultBroadPhase,
    narrow: r3::NarrowPhase,
    bodies: r3::RigidBodySet,
    colliders: r3::ColliderSet,
    impulse_joints: r3::ImpulseJointSet,
    multibody_joints: r3::MultibodyJointSet,
    ccd: r3::CCDSolver,
    query_pipeline: r3::QueryPipeline,
    integration_params: r3::IntegrationParameters,
}

#[allow(dead_code)] // Type alias may be used in future iterations
type Real = f32;

// ------------------------------- Texture Pack Loading -------------------------------

fn load_texture_pack(path: &Path) -> Result<TexturePack> {
    let content = fs::read_to_string(path)?;
    let pack: TexturePack = toml::from_str(&content)?;
    Ok(pack)
}

fn load_texture_from_bytes(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    bytes: &[u8],
    label: &str,
) -> Result<LoadedTexture> {
    println!("Loading texture '{}' from {} bytes", label, bytes.len());
    let img = image::load_from_memory(bytes)?;
    let rgba = img.to_rgba8();
    let dimensions = img.dimensions();
    println!(
        "Texture '{}' loaded successfully: {}x{} pixels",
        label, dimensions.0, dimensions.1
    );

    let size = wgpu::Extent3d {
        width: dimensions.0,
        height: dimensions.1,
        depth_or_array_layers: 1,
    };

    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size,
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });

    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &rgba,
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4 * dimensions.0),
            rows_per_image: Some(dimensions.1),
        },
        size,
    );

    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Nearest,
        mipmap_filter: wgpu::FilterMode::Nearest,
        ..Default::default()
    });

    println!("Successfully created texture resources for '{}'", label);

    Ok(LoadedTexture {
        texture,
        view,
        sampler,
    })
}

fn load_texture_from_file(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    path: &Path,
) -> Result<LoadedTexture> {
    println!("Attempting to load texture from file: {}", path.display());
    if !path.exists() {
        eprintln!("ERROR: Texture file does not exist: {}", path.display());
        return Err(anyhow::anyhow!(
            "Texture file not found: {}",
            path.display()
        ));
    }
    let bytes = fs::read(path)?;
    println!(
        "Successfully read {} bytes from {}",
        bytes.len(),
        path.display()
    );
    load_texture_from_bytes(device, queue, &bytes, &path.to_string_lossy())
}

fn reload_texture_pack(render: &mut RenderStuff, texture_pack_name: &str) -> Result<()> {
    // Load texture pack configuration
    let pack_path =
        Path::new("assets_src/environments").join(format!("{}.toml", texture_pack_name));
    let pack = load_texture_pack(&pack_path)?;

    // Load the ground texture specified in the pack
    let texture_name = if pack.ground.texture.ends_with(".ktx2") {
        // Convert .ktx2 reference to .png for now
        pack.ground.texture.replace(".ktx2", ".png")
    } else {
        pack.ground.texture.clone()
    };

    let texture_path = Path::new("assets").join(&texture_name);
    println!(
        "Loading texture pack '{}' with ground texture: {}",
        texture_pack_name,
        texture_path.display()
    );

    match load_texture_from_file(&render.device, &render.queue, &texture_path) {
        Ok(new_texture) => {
            // Construct normal map path by replacing extension with _n.png
            let tex_stem = Path::new(&texture_name)
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("texture");
            let npath = Path::new("assets").join(format!("{}_n.png", tex_stem));
            let normal_tex = if npath.exists() {
                load_texture_from_file(&render.device, &render.queue, &npath)?
            } else {
                eprintln!(
                    "Warning: Normal map not found at {}. Using default normal map.",
                    npath.display()
                );
                // Use a default normal map (e.g., flat normal)
                // You may need to provide a default normal map in your assets, e.g., "default_n.png"
                let default_npath = Path::new("assets").join("default_n.png");
                load_texture_from_file(&render.device, &render.queue, &default_npath)?
            };

            // Create bind group with both textures
            let combined_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some(&format!("{}-albedo-normal", texture_pack_name)),
                layout: &render.texture_bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&new_texture.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&new_texture.sampler),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::TextureView(&normal_tex.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Sampler(&normal_tex.sampler),
                    },
                ],
            });

            // Update render state
            render.ground_texture = Some(new_texture);
            render.ground_normal = Some(normal_tex);
            render.ground_bind_group = Some(combined_bg);

            println!("Successfully loaded texture pack: {}", texture_pack_name);
            Ok(())
        }
        Err(e) => {
            println!(
                "Failed to load texture for pack '{}': {}",
                texture_pack_name, e
            );
            Err(e)
        }
    }
}

fn generate_environment_objects(physics: &mut Physics, texture_pack_name: &str) -> Vec<Character> {
    // Clear existing objects (keep ground and first few objects as player/sphere)
    let mut handles_to_remove = Vec::new();
    for (handle, body) in physics.bodies.iter() {
        if body.user_data > 2 {
            // Keep player objects (user_data 1, 2)
            handles_to_remove.push(handle);
        }
    }

    for handle in handles_to_remove {
        physics.bodies.remove(
            handle,
            &mut physics.islands,
            &mut physics.colliders,
            &mut physics.impulse_joints,
            &mut physics.multibody_joints,
            true,
        );
    }

    let mut characters = Vec::new();

    // Generate environment-specific objects with more variety
    match texture_pack_name {
        "grassland" => {
            // Add varied trees (different sizes and types)
            for i in 0..12 {
                let x = -15.0 + (i as f32) * 2.5 + (i as f32 * 0.7).sin() * 2.5;
                let z = -8.0 + (i as f32 * 0.9).cos() * 4.0;

                // Vary tree height and width
                let height = 1.2 + (i % 3) as f32 * 0.6;
                let width = 0.2 + (i % 2) as f32 * 0.2;

                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Add varied cottages and structures
            for i in 0..5 {
                let x = 8.0 + (i as f32) * 6.0;
                let z = 2.0 + (i as f32).sin() * 3.0;

                // Create different building types
                let (width, height, depth) = match i % 3 {
                    0 => (1.8, 1.2, 1.5), // Large cottage
                    1 => (1.2, 0.8, 1.0), // Small house
                    _ => (2.2, 1.5, 1.8), // Manor house
                };

                let house_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(20 + i)
                    .build();
                let house_handle = physics.bodies.insert(house_rb);
                let house_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(house_col, house_handle, &mut physics.bodies);
            }

            // Add some boulders and rocks
            for i in 0..6 {
                let x = -5.0 + (i as f32) * 8.0 + (i as f32 * 2.1).sin() * 3.0;
                let z = 8.0 + (i as f32 * 1.7).cos() * 4.0;
                let size = 0.4 + (i % 3) as f32 * 0.3;

                let rock_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size, z))
                    .user_data(60 + i)
                    .build();
                let rock_handle = physics.bodies.insert(rock_rb);
                let rock_col = r3::ColliderBuilder::cuboid(size, size * 0.7, size * 1.2).build();
                physics
                    .colliders
                    .insert_with_parent(rock_col, rock_handle, &mut physics.bodies);
            }

            // Add characters for grassland environment
            for i in 0..6 {
                let x = 3.0 + (i as f32) * 4.0;
                let z = -2.0 + (i as f32 * 1.3).sin() * 6.0;
                let pos = Vec3::new(x, -1.0, z);

                let char_type = match i % 4 {
                    0 => CharacterType::Villager,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Merchant,
                    _ => CharacterType::Animal,
                };

                let mut character = Character::new(pos, char_type);

                // Set up patrol routes
                character.patrol_points = vec![
                    pos,
                    pos + Vec3::new(3.0, 0.0, 0.0),
                    pos + Vec3::new(3.0, 0.0, 3.0),
                    pos + Vec3::new(0.0, 0.0, 3.0),
                ];
                character.target_position = character.patrol_points[1];

                characters.push(character);
            }
        }
        "desert" => {
            // Add varied cacti (different heights and arrangements)
            for i in 0..8 {
                let x = -12.0 + (i as f32) * 3.5 + (i as f32 * 1.2).sin() * 2.0;
                let z = -4.0 + (i as f32 * 0.8).cos() * 5.0;

                // Create different cactus types
                let (width, height) = match i % 4 {
                    0 => (0.15, 2.0), // Tall thin cactus
                    1 => (0.25, 1.2), // Medium barrel cactus
                    2 => (0.2, 1.8),  // Regular cactus
                    _ => (0.3, 0.8),  // Short wide cactus
                };

                let cactus_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(30 + i)
                    .build();
                let cactus_handle = physics.bodies.insert(cactus_rb);
                let cactus_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics.colliders.insert_with_parent(
                    cactus_col,
                    cactus_handle,
                    &mut physics.bodies,
                );
            }

            // Add varied adobe structures
            for i in 0..4 {
                let x = 10.0 + (i as f32) * 7.0;
                let z = 1.0 + (i as f32).cos() * 3.0;

                // Different adobe building styles
                let (width, height, depth) = match i % 3 {
                    0 => (1.5, 1.0, 1.5), // Square adobe house
                    1 => (2.0, 0.8, 1.2), // Rectangular building
                    _ => (1.8, 1.3, 1.8), // Tall adobe tower
                };

                let adobe_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(40 + i)
                    .build();
                let adobe_handle = physics.bodies.insert(adobe_rb);
                let adobe_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(adobe_col, adobe_handle, &mut physics.bodies);
            }

            // Add desert rocks and formations
            for i in 0..8 {
                let x = -8.0 + (i as f32) * 6.0 + (i as f32 * 1.9).sin() * 4.0;
                let z = 10.0 + (i as f32 * 1.3).cos() * 6.0;
                let size = 0.5 + (i % 4) as f32 * 0.4;

                let formation_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size, z))
                    .user_data(70 + i)
                    .build();
                let formation_handle = physics.bodies.insert(formation_rb);
                let formation_col =
                    r3::ColliderBuilder::cuboid(size, size * 1.5, size * 0.8).build();
                physics.colliders.insert_with_parent(
                    formation_col,
                    formation_handle,
                    &mut physics.bodies,
                );
            }

            // Add characters for desert environment
            for i in 0..4 {
                let x = 5.0 + (i as f32) * 8.0;
                let z = -3.0 + (i as f32 * 0.9).sin() * 4.0;
                let pos = Vec3::new(x, -1.0, z);

                let char_type = match i % 3 {
                    0 => CharacterType::Merchant,
                    1 => CharacterType::Guard,
                    _ => CharacterType::Animal,
                };

                let mut character = Character::new(pos, char_type);

                // Set up larger patrol routes for desert
                character.patrol_points = vec![
                    pos,
                    pos + Vec3::new(6.0, 0.0, 2.0),
                    pos + Vec3::new(4.0, 0.0, 5.0),
                    pos + Vec3::new(-2.0, 0.0, 3.0),
                ];
                character.target_position = character.patrol_points[1];

                characters.push(character);
            }
        }
        _ => {
            // Enhanced default environment with more variety
            for i in 0..8 {
                let x = -8.0 + (i as f32) * 2.0;
                let z = 3.0 + (i % 2) as f32 * 4.0;
                let height = 0.8 + (i % 3) as f32 * 0.5;

                let obj_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(50 + i)
                    .build();
                let obj_handle = physics.bodies.insert(obj_rb);
                let obj_col = r3::ColliderBuilder::cuboid(0.5, height, 0.5).build();
                physics
                    .colliders
                    .insert_with_parent(obj_col, obj_handle, &mut physics.bodies);
            }

            // Add default characters
            for i in 0..3 {
                let x = (i as f32) * 4.0;
                let z = 0.0;
                let pos = Vec3::new(x, -1.0, z);
                let character = Character::new(pos, CharacterType::Villager);
                characters.push(character);
            }
        }
    }

    characters
}

// ------------------------------- Main entry -------------------------------

fn main() -> Result<()> {
    // Use pollster to block on the async run
    pollster::block_on(run())
}

async fn run() -> Result<()> {
    // Generate default textures at startup if missing (seed -> vary looks)
    let seed = 0xA57; // change to taste / hook to key for regeneration
    texture_synth::ensure_textures("assets", seed, false)?;

    // Boilerplate: create event loop and window
    let event_loop = EventLoop::new()?;
    let window = std::sync::Arc::new(
        WindowBuilder::new()
            .with_title("AstraWeave Unified Showcase (Modified)")
            .build(&event_loop)?,
    );
    // Setup renderer, UI, physics
    let mut render = setup_renderer(window.clone()).await?;
    let mut physics = build_physics_world();

    // Initialize default environment and texture pack
    let mut characters = generate_environment_objects(&mut physics, "grassland");

    // Load the initial grassland texture pack
    if let Err(e) = reload_texture_pack(&mut render, "grassland") {
        println!(
            "Warning: Failed to load initial grassland texture pack: {}",
            e
        );
        println!("Continuing with default textures...");
        println!(
            "Note: You can still switch texture packs using keys 1 (grassland) and 2 (desert)"
        );
    } else {
        println!("Successfully loaded initial grassland texture pack");
        println!(
            "Controls: WASD+mouse=camera, P=pause physics, T=teleport sphere, E=apply impulse"
        );
        println!("Texture packs: Press 1 for grassland, 2 for desert");
    }

    let mut instances = build_show_instances();
    let mut ui = UiState::default();

    // Use proper camera system from astraweave-render
    let mut camera = RenderCamera {
        position: Vec3::new(0.0, 0.0, 5.0),
        yaw: 0.0,
        pitch: 0.0,
        fovy: 60f32.to_radians(),
        aspect: 1.0,
        znear: 0.01,
        zfar: 5000.0,
    };
    let mut camera_controller = CameraController::new(8.0, 0.002);
    let mut input = InputState::default();
    let mut last = Instant::now();
    let mut fps_acc = 0.0;
    let mut fps_cnt = 0u32;

    let elwt = event_loop;
    let _ = elwt.run(move |event, elwt_window_target| {
        elwt_window_target.set_control_flow(winit::event_loop::ControlFlow::Poll);
        match event {
            Event::WindowEvent {
                event: win_event, ..
            } => {
                match win_event {
                    WindowEvent::CloseRequested => {
                        elwt_window_target.exit();
                    }
                    WindowEvent::KeyboardInput {
                        event:
                            KeyEvent {
                                physical_key,
                                state,
                                ..
                            },
                        ..
                    } => {
                        let pressed = state == ElementState::Pressed;
                        match physical_key {
                            PhysicalKey::Code(code) => {
                                camera_controller.process_keyboard(code, pressed);
                                match code {
                                    KeyCode::Escape => {
                                        if pressed {
                                            elwt_window_target.exit();
                                        }
                                    }
                                    KeyCode::KeyP => {
                                        if pressed {
                                            ui.physics_paused = !ui.physics_paused;
                                        }
                                    }
                                    KeyCode::KeyT => {
                                        if pressed {
                                            // Teleport sphere a few meters in front of camera
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );
                                            let target = camera.position
                                                + forward * 4.0
                                                + Vec3::new(0.0, -0.5, 0.0);
                                            teleport_sphere_to(&mut physics, target);
                                        }
                                    }
                                    KeyCode::KeyE => {
                                        if pressed {
                                            // Raycast forward and apply impulse to first hit dynamic body
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );

                                            // Create a ray for the query
                                            let ray_origin = nalgebra::Point3::new(
                                                camera.position.x,
                                                camera.position.y,
                                                camera.position.z,
                                            );
                                            let ray_dir = nalgebra::Vector3::new(
                                                forward.x, forward.y, forward.z,
                                            );
                                            let ray = r3::Ray::new(ray_origin, ray_dir);

                                            // Update the query pipeline with just the colliders
                                            physics.query_pipeline.update(&physics.colliders);

                                            // Cast the ray
                                            if let Some((h, _toi)) =
                                                physics.query_pipeline.cast_ray(
                                                    &physics.bodies,
                                                    &physics.colliders,
                                                    &ray,
                                                    15.0,
                                                    true,
                                                    r3::QueryFilter::default(),
                                                )
                                            {
                                                if let Some(body) =
                                                    physics.bodies.get_mut(r3::RigidBodyHandle(h.0))
                                                {
                                                    if !body.is_fixed() {
                                                        let impulse = nalgebra::Vector3::new(
                                                            forward.x * 3.0,
                                                            1.0,
                                                            forward.z * 3.0,
                                                        );
                                                        body.apply_impulse(impulse, true);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::Digit1 => {
                                        if pressed {
                                            let pack_name = "grassland";
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                ui.current_texture_pack = pack_name.to_string();
                                                ui.info_text = format!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                            }
                                        }
                                    }
                                    KeyCode::Digit2 => {
                                        if pressed {
                                            let pack_name = "desert";
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                ui.current_texture_pack = pack_name.to_string();
                                                ui.info_text = format!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                    WindowEvent::MouseInput { state, button, .. } => {
                        camera_controller
                            .process_mouse_button(button, state == ElementState::Pressed);
                        if button == winit::event::MouseButton::Right {
                            let pressed = state == ElementState::Pressed;
                            // Grab or release cursor for reliable deltas
                            if pressed {
                                let _ = window.set_cursor_grab(CursorGrabMode::Locked);
                                window.set_cursor_visible(false);
                            } else {
                                let _ = window.set_cursor_grab(CursorGrabMode::None);
                                window.set_cursor_visible(true);
                            }
                        }
                    }
                    WindowEvent::MouseWheel {
                        delta: MouseScrollDelta::LineDelta(_, y),
                        ..
                    } => {
                        input.scroll_delta = y;
                    }
                    WindowEvent::Resized(size) => {
                        render.surface_cfg.width = size.width.max(1);
                        render.surface_cfg.height = size.height.max(1);
                        render
                            .surface
                            .configure(&render.device, &render.surface_cfg);
                        render.depth_view = create_depth(
                            &render.device,
                            render.surface_cfg.width,
                            render.surface_cfg.height,
                            render.msaa_samples,
                        );

                        // Update UI info with character count
                        ui.info_text = format!(
                            "Environment: {} ({} characters)",
                            ui.current_texture_pack,
                            characters.len()
                        );
                    }
                    WindowEvent::RedrawRequested => {
                        let now = Instant::now();
                        let dt = now - last;
                        last = now;

                        // smooth FPS
                        let fps = 1.0 / dt.as_secs_f32().max(1e-5);
                        fps_acc += fps;
                        fps_cnt += 1;
                        if fps_cnt >= 30 {
                            ui.fps_text = format!("{:.1} fps", fps_acc / fps_cnt as f32);
                            fps_acc = 0.0;
                            fps_cnt = 0;
                        }

                        // Update camera
                        camera.aspect = (render.surface_cfg.width as f32 * ui.resolution_scale)
                            .max(1.0)
                            / (render.surface_cfg.height as f32 * ui.resolution_scale).max(1.0);

                        // Adjust camera speed via scroll
                        if input.scroll_delta.abs() > 0.1 {
                            camera_controller.speed =
                                (camera_controller.speed + input.scroll_delta).clamp(1.0, 50.0);
                            ui.camera_speed = camera_controller.speed;
                            input.scroll_delta = 0.0;
                        }

                        // Update camera with controller
                        camera_controller.update_camera(&mut camera, dt.as_secs_f32());

                        // Update characters
                        for character in &mut characters {
                            character.update(dt.as_secs_f32());
                        }

                        // Physics
                        if !ui.physics_paused {
                            physics_step(&mut physics);
                        }

                        // Sync sim to render
                        sync_instances_from_physics(&physics, &characters, &mut instances);
                        render.instance_count = instances.len() as u32;

                        if !instances.is_empty() {
                            render.queue.write_buffer(
                                &render.instance_vb,
                                0,
                                bytemuck::cast_slice(&instances),
                            );
                        }

                        // Camera uniform
                        let cam = GpuCamera {
                            view_proj: camera.vp().to_cols_array(),
                        };
                        render
                            .queue
                            .write_buffer(&render.camera_ub, 0, bytemuck::bytes_of(&cam));

                        // Render
                        let frame = match render.surface.get_current_texture() {
                            Ok(f) => f,
                            Err(_) => {
                                render
                                    .surface
                                    .configure(&render.device, &render.surface_cfg);
                                render.surface.get_current_texture().unwrap()
                            }
                        };
                        let view = frame
                            .texture
                            .create_view(&wgpu::TextureViewDescriptor::default());
                        let mut encoder =
                            render
                                .device
                                .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                                    label: Some("main-encoder"),
                                });
                        {
                            let mut rp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("main-pass"),
                                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                                    view: &view,
                                    resolve_target: None,
                                    ops: wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(wgpu::Color {
                                            r: 0.05,
                                            g: 0.07,
                                            b: 0.09,
                                            a: 1.0,
                                        }),
                                        store: wgpu::StoreOp::Store,
                                    },
                                })],
                                depth_stencil_attachment: Some(
                                    wgpu::RenderPassDepthStencilAttachment {
                                        view: &render.depth_view,
                                        depth_ops: Some(wgpu::Operations {
                                            load: wgpu::LoadOp::Clear(1.0),
                                            store: wgpu::StoreOp::Store,
                                        }),
                                        stencil_ops: None,
                                    },
                                ),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            rp.set_pipeline(&render.pipeline);
                            rp.set_bind_group(0, &render.camera_bg, &[]);
                            if let Some(ref texture_bg) = render.ground_bind_group {
                                rp.set_bind_group(1, texture_bg, &[]);
                            }
                            rp.set_vertex_buffer(0, render.cube_vb.slice(..));
                            rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                            rp.set_index_buffer(
                                render.cube_ib.slice(..),
                                wgpu::IndexFormat::Uint16,
                            );
                            if render.instance_count > 0 {
                                rp.draw_indexed(
                                    0..render.cube_index_count,
                                    0,
                                    0..render.instance_count,
                                );
                            }
                        }
                        render.queue.submit(Some(encoder.finish()));
                        frame.present();
                    }
                    _ => {}
                }
            }
            Event::AboutToWait => {
                window.request_redraw();
            }
            Event::DeviceEvent {
                event: DeviceEvent::MouseMotion { delta },
                ..
            } => {
                // Use proper mouse position handling for camera controller
                let pos = Vec2::new(delta.0 as f32, delta.1 as f32);
                camera_controller.process_mouse_move(&mut camera, pos);
            }
            _ => {}
        }
    });
    Ok(())
}

// ---------------- Helper functions for default textures ----------------

fn create_default_albedo_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let white_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-white"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &white_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[255, 255, 255, 255], // RGBA white
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = white_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor::default());
    Ok(LoadedTexture {
        texture: white_texture,
        view,
        sampler,
    })
}

fn create_default_normal_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let normal_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-normal"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &normal_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[128, 128, 255, 255], // Default normal pointing up (0, 0, 1) in normal map encoding
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = normal_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor::default());
    Ok(LoadedTexture {
        texture: normal_texture,
        view,
        sampler,
    })
}

// ---------------- renderer setup ----------------
async fn setup_renderer(window: std::sync::Arc<winit::window::Window>) -> Result<RenderStuff> {
    let size = window.inner_size();
    println!(
        "Setting up wgpu renderer with window size: {}x{}",
        size.width, size.height
    );

    // Enable debug features for better error reporting
    let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
        backends: wgpu::Backends::all(),
        flags: wgpu::InstanceFlags::DEBUG | wgpu::InstanceFlags::VALIDATION,
        ..Default::default()
    });

    println!("Creating surface...");
    let surface = instance.create_surface(window.clone())?;

    println!("Requesting adapter...");
    let adapter = instance
        .request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        })
        .await
        .unwrap();

    println!("Adapter found: {:?}", adapter.get_info());

    println!("Requesting device...");
    let (device, queue) = adapter
        .request_device(
            &wgpu::DeviceDescriptor {
                label: Some("device"),
                required_features: wgpu::Features::empty(),
                required_limits: wgpu::Limits::default(),
            },
            None, // Enable validation for debug builds: Some(&std::path::Path::new("wgpu_trace"))
        )
        .await
        .unwrap();

    println!("Device created successfully");

    let msaa_samples = 1u32;
    let caps = surface.get_capabilities(&adapter);
    println!("Surface capabilities: {:?}", caps);

    let surface_format = caps
        .formats
        .iter()
        .copied()
        .find(|f| f.is_srgb())
        .unwrap_or(caps.formats[0]);

    println!("Selected surface format: {:?}", surface_format);
    let surface_cfg = wgpu::SurfaceConfiguration {
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        format: surface_format,
        width: size.width.max(1),
        height: size.height.max(1),
        present_mode: caps.present_modes[0],
        alpha_mode: caps.alpha_modes[0],
        view_formats: vec![],
        desired_maximum_frame_latency: 2,
    };
    surface.configure(&device, &surface_cfg);
    let depth_view = create_depth(&device, surface_cfg.width, surface_cfg.height, msaa_samples);

    // create cube buffers
    let cube_vb = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("cube-vertices"),
        contents: bytemuck::cast_slice(CUBE_VERTICES),
        usage: wgpu::BufferUsages::VERTEX,
    });
    let cube_ib = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("cube-indices"),
        contents: bytemuck::cast_slice(CUBE_INDICES),
        usage: wgpu::BufferUsages::INDEX,
    });
    let cube_index_count = CUBE_INDICES.len() as u32;

    // Create camera uniform buffer and bind group layout
    let camera_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("camera-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    let camera_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("camera-layout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    });
    let camera_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("camera-bg"),
        layout: &camera_bg_layout,
        entries: &[wgpu::BindGroupEntry {
            binding: 0,
            resource: camera_ub.as_entire_binding(),
        }],
    });

    // Texture bind group layout (for albedo + normal mapping)
    let texture_bind_group_layout =
        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("albedo+normal"),
            entries: &[
                // binding 0: albedo texture
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 1: albedo sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // binding 2: normal texture
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 3: normal sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 3,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
            ],
        });

    // Try to load grass texture, fallback to default if not available
    let (ground_texture, ground_normal, ground_bind_group) =
        match load_texture_from_file(&device, &queue, Path::new("assets/grass.png")) {
            Ok(texture) => {
                // Try to load corresponding normal map
                let normal_texture = match load_texture_from_file(
                    &device,
                    &queue,
                    Path::new("assets/grass_n.png"),
                ) {
                    Ok(normal) => normal,
                    Err(_) => create_default_normal_texture(&device, &queue)?,
                };

                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("ground-texture-bg"),
                    layout: &texture_bind_group_layout,
                    entries: &[
                        wgpu::BindGroupEntry {
                            binding: 0,
                            resource: wgpu::BindingResource::TextureView(&texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 1,
                            resource: wgpu::BindingResource::Sampler(&texture.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 2,
                            resource: wgpu::BindingResource::TextureView(&normal_texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 3,
                            resource: wgpu::BindingResource::Sampler(&normal_texture.sampler),
                        },
                    ],
                });
                (Some(texture), Some(normal_texture), Some(bind_group))
            }
            Err(_) => {
                // Create default textures as fallback
                let default_albedo = create_default_albedo_texture(&device, &queue)?;
                let default_normal = create_default_normal_texture(&device, &queue)?;

                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("default-texture-bg"),
                    layout: &texture_bind_group_layout,
                    entries: &[
                        wgpu::BindGroupEntry {
                            binding: 0,
                            resource: wgpu::BindingResource::TextureView(&default_albedo.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 1,
                            resource: wgpu::BindingResource::Sampler(&default_albedo.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 2,
                            resource: wgpu::BindingResource::TextureView(&default_normal.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 3,
                            resource: wgpu::BindingResource::Sampler(&default_normal.sampler),
                        },
                    ],
                });
                (Some(default_albedo), Some(default_normal), Some(bind_group))
            }
        };

    // Instance buffer (increased size for environment objects)
    let max_instances = 100;
    let instance_vb = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("instance-buffer"),
        size: (std::mem::size_of::<InstanceRaw>() * max_instances) as u64,
        usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });

    // Create pipeline with procedural shader
    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADER)),
    });
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("pipeline-layout"),
        bind_group_layouts: &[&camera_bg_layout, &texture_bind_group_layout],
        push_constant_ranges: &[],
    });

    let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader_module,
            entry_point: "vs_main",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[wgpu::VertexAttribute {
                        format: wgpu::VertexFormat::Float32x3,
                        offset: 0,
                        shader_location: 0,
                    }],
                },
                // instance transform (4 vec4 + color)
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 0,
                            shader_location: 1,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 16,
                            shader_location: 2,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 32,
                            shader_location: 3,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 48,
                            shader_location: 4,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 64,
                            shader_location: 5,
                        },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader_module,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: surface_format,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            strip_index_format: None,
            front_face: wgpu::FrontFace::Ccw,
            cull_mode: Some(wgpu::Face::Back),
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: DEPTH_FORMAT,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState::default(),
        }),
        multisample: wgpu::MultisampleState {
            count: msaa_samples,
            mask: !0,
            alpha_to_coverage_enabled: false,
        },
        multiview: None,
    });

    Ok(RenderStuff {
        surface,
        surface_cfg,
        device,
        queue,
        depth_view,
        pipeline,
        cube_vb,
        cube_ib,
        cube_index_count,
        camera_ub,
        camera_bg,
        instance_vb,
        instance_count: 0, // Will be updated dynamically
        msaa_samples,
        ground_texture,
        texture_bind_group_layout,
        ground_bind_group,
        ground_normal,
    })
}

fn create_depth(device: &wgpu::Device, width: u32, height: u32, samples: u32) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth"),
        size: wgpu::Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format: DEPTH_FORMAT,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

// ---------------- shader with procedural ground/sky ----------------

const SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };
@group(0) @binding(0) var<uniform> u_camera: Camera;

@group(1) @binding(0) var ground_texture: texture_2d<f32>;
@group(1) @binding(1) var ground_sampler: sampler;
@group(1) @binding(2) var ground_normal: texture_2d<f32>;
@group(1) @binding(3) var normal_sampler: sampler;

struct VsIn {
  @location(0) pos: vec3<f32>,
  @location(1) m0: vec4<f32>,
  @location(2) m1: vec4<f32>,
  @location(3) m2: vec4<f32>,
  @location(4) m3: vec4<f32>,
  @location(5) color: vec4<f32>,
};

struct VsOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
  @location(1) world_pos: vec3<f32>,
  @location(2) view_dir: vec3<f32>,
};

@vertex
fn vs_main(in: VsIn) -> VsOut {
  let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
  var out: VsOut;
  let world = model * vec4<f32>(in.pos, 1.0);
  out.pos = u_camera.view_proj * world;
  out.color = in.color;
  out.world_pos = world.xyz;
  
  // Calculate view direction for sky effects
  let camera_pos = vec3<f32>(0.0, 2.0, 0.0); // Approximate camera position for sky
  out.view_dir = normalize(world.xyz - camera_pos);
  
  return out;
}

// Enhanced sky with realistic atmosphere, clouds, and sun
fn sky_color(view_dir: vec3<f32>, time: f32) -> vec3<f32> {
  let dir_y = view_dir.y;
  
  // Basic atmosphere gradient
  let horizon_color = vec3<f32>(0.7, 0.8, 0.9);
  let zenith_color = vec3<f32>(0.3, 0.5, 0.8);
  let sunset_color = vec3<f32>(1.0, 0.6, 0.3);
  
  // Sun position (moves over time for day/night cycle)
  let sun_dir = normalize(vec3<f32>(cos(time * 0.1) * 0.8, 0.6, sin(time * 0.1) * 0.8));
  let sun_dot = max(dot(view_dir, sun_dir), 0.0);
  
  // Atmospheric scattering approximation
  let sun_influence = pow(sun_dot, 512.0) * 2.0 + pow(sun_dot, 32.0) * 0.5;
  let sunset_influence = max(0.0, -sun_dir.y + 0.1) * pow(max(0.0, -dir_y + 0.1), 2.0);
  
  // Base sky gradient
  let t = clamp(dir_y * 0.5 + 0.5, 0.0, 1.0);
  var sky = mix(horizon_color, zenith_color, t);
  
  // Add sunset colors at horizon
  sky = mix(sky, sunset_color, sunset_influence);
  
  // Add sun
  sky += vec3<f32>(1.0, 0.9, 0.7) * sun_influence;
  
  // Cloud noise function
  let cloud_scale = 0.8;
  let cloud_time = time * 0.05;
  let cloud_pos = view_dir.xz * cloud_scale + vec2<f32>(cloud_time, cloud_time * 0.7);
  
  // Simple noise for clouds
  let cloud_noise1 = sin(cloud_pos.x * 3.14) * cos(cloud_pos.y * 2.71) * 0.5 + 0.5;
  let cloud_noise2 = sin(cloud_pos.x * 6.28 + 1.0) * cos(cloud_pos.y * 5.42 + 1.5) * 0.5 + 0.5;
  let cloud_density = pow(max(0.0, cloud_noise1 * cloud_noise2 - 0.4), 2.0);
  
  // Apply clouds only in upper sky
  let cloud_mask = clamp(dir_y * 2.0, 0.0, 1.0);
  let cloud_color = vec3<f32>(0.9, 0.9, 0.95);
  sky = mix(sky, cloud_color, cloud_density * cloud_mask * 0.8);
  
  return sky;
}

// Enhanced terrain with height variation
fn get_terrain_height(world_pos: vec2<f32>) -> f32 {
  let scale = 0.1;
  let pos = world_pos * scale;
  
  // Multi-octave noise for terrain
  var height = 0.0;
  height += sin(pos.x * 2.0) * cos(pos.y * 1.5) * 0.5;
  height += sin(pos.x * 4.0 + 1.0) * cos(pos.y * 3.0 + 0.5) * 0.25;
  height += sin(pos.x * 8.0 + 2.0) * cos(pos.y * 6.0 + 1.0) * 0.125;
  
  return height * 2.0; // Scale height variation
}

@fragment
fn fs_main(in: VsOut) -> @location(0) vec4<f32> {
  var col = in.color.rgb;
  let time = 1000.0; // TODO: Pass actual time as uniform
  
  // Enhanced ground rendering with height-based terrain
  let ground_y = -2.0;
  let terrain_height = get_terrain_height(in.world_pos.xz);
  let terrain_surface = ground_y + terrain_height;
  let dist = abs(in.world_pos.y - terrain_surface);
  
  if (dist < 0.6) {
    let scale = 4.0;
    let uv = vec2<f32>(in.world_pos.x / scale, in.world_pos.z / scale);
    var tex_color = textureSample(ground_texture, ground_sampler, uv).rgb;
    
    // Height-based texture blending
    let height_factor = clamp((terrain_height + 1.0) / 2.0, 0.0, 1.0);
    let rock_color = vec3<f32>(0.4, 0.35, 0.3);
    tex_color = mix(tex_color, rock_color, height_factor * 0.3);
    
    // Sample normal map for enhanced surface detail
    let normal_sample = textureSample(ground_normal, normal_sampler, uv).rgb;
    let normal = normalize(normal_sample * 2.0 - 1.0);
    
    // Enhanced lighting with multiple light sources
    let sun_dir = normalize(vec3<f32>(0.6, 0.8, 0.3));
    let ambient_dir = vec3<f32>(0.0, 1.0, 0.0);
    
    let sun_ndotl = max(dot(normal, sun_dir), 0.0);
    let ambient_ndotl = max(dot(normal, ambient_dir), 0.0);
    
    let sun_lighting = sun_ndotl * vec3<f32>(1.0, 0.95, 0.8);
    let ambient_lighting = ambient_ndotl * vec3<f32>(0.4, 0.5, 0.6) * 0.3;
    let lighting = sun_lighting + ambient_lighting + vec3<f32>(0.1, 0.1, 0.15); // Base ambient
    
    // Enhanced checkerboard pattern with terrain variation
    let checker_scale = 1.5 + terrain_height * 0.2;
    let cx = floor(in.world_pos.x / checker_scale);
    let cz = floor(in.world_pos.z / checker_scale);
    let checker = f32((i32(cx + cz) & 1)) * 0.08;
    
    col = tex_color * lighting * (0.95 + checker);
    
    // Add atmospheric perspective
    let distance = length(in.world_pos);
    let fog_factor = clamp(distance / 50.0, 0.0, 1.0);
    let fog_color = sky_color(normalize(in.world_pos), time);
    col = mix(col, fog_color, fog_factor * 0.3);
  } else {
    // Render sky for non-ground objects or background
    let sky = sky_color(in.view_dir, time);
    col = col * 0.7 + sky * 0.3; // Blend object color with sky ambient
  }
  
  return vec4<f32>(col, 1.0);
}
"#;

// ---------------- physics world build/step & instance sync ----------------

fn build_physics_world() -> Physics {
    let mut bodies = r3::RigidBodySet::new();
    let mut colliders = r3::ColliderSet::new();
    let gravity = nalgebra::Vector3::new(0.0, -9.81, 0.0);
    // Ground
    let ground = r3::RigidBodyBuilder::fixed()
        .translation(nalgebra::Vector3::new(0.0, -2.0, 0.0))
        .user_data(0)
        .build();
    let g_handle = bodies.insert(ground);
    let g_col = r3::ColliderBuilder::cuboid(100.0, 0.5, 100.0).build();
    colliders.insert_with_parent(g_col, g_handle, &mut bodies);
    // Stack of boxes
    for y in 0..5 {
        for x in 0..5 {
            let rb = r3::RigidBodyBuilder::dynamic()
                .translation(nalgebra::Vector3::new(
                    -2.5 + x as f32 * 0.7,
                    -1.0 + y as f32 * 0.7,
                    0.0,
                ))
                .user_data(1)
                .build();
            let h = bodies.insert(rb);
            let c = r3::ColliderBuilder::cuboid(0.3, 0.3, 0.3)
                .restitution(0.2)
                .friction(0.8)
                .build();
            colliders.insert_with_parent(c, h, &mut bodies);
        }
    }
    // Sphere
    let s_rb = r3::RigidBodyBuilder::dynamic()
        .translation(nalgebra::Vector3::new(1.8, 1.0, 0.0))
        .ccd_enabled(true)
        .user_data(2)
        .build();
    let s_handle = bodies.insert(s_rb);
    let s_col = r3::ColliderBuilder::ball(0.35)
        .restitution(0.5)
        .friction(0.3)
        .build();
    colliders.insert_with_parent(s_col, s_handle, &mut bodies);

    Physics {
        pipeline: r3::PhysicsPipeline::new(),
        gravity,
        islands: r3::IslandManager::new(),
        broad: r3::DefaultBroadPhase::new(),
        narrow: r3::NarrowPhase::new(),
        bodies,
        colliders,
        impulse_joints: r3::ImpulseJointSet::new(),
        multibody_joints: r3::MultibodyJointSet::new(),
        ccd: r3::CCDSolver::new(),
        query_pipeline: r3::QueryPipeline::new(),
        integration_params: r3::IntegrationParameters {
            dt: 1.0 / 60.0,
            ..Default::default()
        },
    }
}

fn physics_step(p: &mut Physics) {
    let hooks = ();
    let events = ();
    p.pipeline.step(
        &p.gravity,
        &p.integration_params,
        &mut p.islands,
        &mut p.broad,
        &mut p.narrow,
        &mut p.bodies,
        &mut p.colliders,
        &mut p.impulse_joints,
        &mut p.multibody_joints,
        &mut p.ccd,
        Some(&mut p.query_pipeline),
        &hooks,
        &events,
    );
}

fn teleport_sphere_to(p: &mut Physics, pos: Vec3) {
    let target = p.bodies.iter_mut().find(|(_, b)| b.user_data == 2);
    if let Some((_, body)) = target {
        body.set_translation(nalgebra::Vector3::new(pos.x, pos.y, pos.z), true);
        body.set_linvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
        body.set_angvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
    }
}

fn sync_instances_from_physics(p: &Physics, characters: &[Character], out: &mut Vec<InstanceRaw>) {
    // Resize output vector to accommodate all objects
    out.clear();

    // Add physics objects
    for (h, body) in p.bodies.iter() {
        // No skipping  we want the ground cube drawn so the ground shader branch runs.

        let xf = body.position();
        let iso = xf.to_homogeneous();
        let base_m = Mat4::from_cols_array_2d(&iso.fixed_view::<4, 4>(0, 0).into());

        // Default: no scale (unit cube)
        let mut model_m = base_m;

        // If this is the ground (user_data == 0 and fixed), scale the render
        // instance to match the collider half-extents (Rapier cuboid uses half-extents).
        if body.is_fixed() && body.user_data == 0 {
            // Find any collider attached to this body; prefer a Cuboid.
            if let Some((_, col)) = p.colliders.iter().find(|(_, c)| c.parent() == Some(h)) {
                if let Some(cuboid) = col.shape().as_cuboid() {
                    let he = cuboid.half_extents; // nalgebra::Vector
                    // Full extents = half_extents * 2
                    let sx = he.x * 2.0;
                    let sy = he.y * 2.0;
                    let sz = he.z * 2.0;
                    let scale_m = Mat4::from_scale(Vec3::new(sx, sy, sz));
                    model_m = base_m * scale_m;
                } else {
                    // Fallback: reasonable plane size if shape not Cuboid
                    let scale_m = Mat4::from_scale(Vec3::new(200.0, 1.0, 200.0));
                    model_m = base_m * scale_m;
                }
            } else {
                // Fallback if no collider found (shouldn't happen)
                let scale_m = Mat4::from_scale(Vec3::new(200.0, 1.0, 200.0));
                model_m = base_m * scale_m;
            }
        }

        // Color based on object type; give ground a neutral tint
        let color = match body.user_data {
            0 => [0.95, 0.95, 0.95, 1.0],      // Ground
            1 => [0.9, 0.6, 0.2, 1.0],         // Original boxes (orange)
            2 => [0.1, 0.8, 0.9, 1.0],         // Sphere (cyan)
            10..=19 => [0.2, 0.8, 0.3, 1.0],   // Trees (green)
            20..=29 => [0.7, 0.5, 0.3, 1.0],   // Cottages/Houses (brown)
            30..=39 => [0.3, 0.8, 0.4, 1.0],   // Cacti (bright green)
            40..=49 => [0.8, 0.7, 0.5, 1.0],   // Adobe houses (sandy)
            50..=59 => [0.6, 0.6, 0.6, 1.0],   // Generic objects (gray)
            60..=69 => [0.4, 0.4, 0.35, 1.0],  // Rocks/Boulders (dark gray)
            70..=79 => [0.6, 0.45, 0.35, 1.0], // Desert formations (reddish brown)
            _ => [0.5, 0.5, 0.5, 1.0],         // Unknown (dark gray)
        };

        out.push(InstanceRaw {
            model: model_m.to_cols_array(),
            color,
        });
    }

    // Add character instances
    for character in characters {
        // Create a transform matrix for the character
        let scale = 0.4; // Characters are smaller than buildings
        let translation = Mat4::from_translation(character.position);
        let scaling = Mat4::from_scale(Vec3::splat(scale));

        // Add some simple animation based on time
        let bob_offset = (character.animation_time * 3.0).sin() * 0.1;
        let animation_transform = Mat4::from_translation(Vec3::new(0.0, bob_offset, 0.0));

        let model_matrix = translation * animation_transform * scaling;

        out.push(InstanceRaw {
            model: model_matrix.to_cols_array(),
            color: character.get_color(),
        });
    }
}

fn build_show_instances() -> Vec<InstanceRaw> {
    // Start with empty instances - they'll be populated by physics sync
    Vec::new()
}
